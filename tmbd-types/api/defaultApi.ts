/**
 * TMDB API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest from "request";
import http from "http";

/* tslint:disable:no-unused-locals */
import { AccountDetails200Response } from "../model/accountDetails200Response";
import { AccountFavoriteTv200Response } from "../model/accountFavoriteTv200Response";
import { AccountGetFavorites200Response } from "../model/accountGetFavorites200Response";
import { AccountLists200Response } from "../model/accountLists200Response";
import { AccountRatedMovies200Response } from "../model/accountRatedMovies200Response";
import { AccountRatedTv200Response } from "../model/accountRatedTv200Response";
import { AccountRatedTvEpisodes200Response } from "../model/accountRatedTvEpisodes200Response";
import { AccountWatchlistMovies200Response } from "../model/accountWatchlistMovies200Response";
import { AccountWatchlistTv200Response } from "../model/accountWatchlistTv200Response";
import { AlternativeNamesCopy200Response } from "../model/alternativeNamesCopy200Response";
import { AuthenticationCreateGuestSession200Response } from "../model/authenticationCreateGuestSession200Response";
import { AuthenticationCreateRequestToken200Response } from "../model/authenticationCreateRequestToken200Response";
import { AuthenticationCreateSession200Response } from "../model/authenticationCreateSession200Response";
import { AuthenticationCreateSessionFromLogin200Response } from "../model/authenticationCreateSessionFromLogin200Response";
import { AuthenticationCreateSessionFromV4Token200Response } from "../model/authenticationCreateSessionFromV4Token200Response";
import { AuthenticationDeleteSession200Response } from "../model/authenticationDeleteSession200Response";
import { AuthenticationValidateKey200Response } from "../model/authenticationValidateKey200Response";
import { AuthenticationValidateKey401Response } from "../model/authenticationValidateKey401Response";
import { CertificationMovieList200Response } from "../model/certificationMovieList200Response";
import { CertificationsTvList200Response } from "../model/certificationsTvList200Response";
import { ChangesMovieList200Response } from "../model/changesMovieList200Response";
import { ChangesPeopleList200Response } from "../model/changesPeopleList200Response";
import { ChangesTvList200Response } from "../model/changesTvList200Response";
import { CollectionDetails200Response } from "../model/collectionDetails200Response";
import { CollectionImages200Response } from "../model/collectionImages200Response";
import { CollectionTranslations200Response } from "../model/collectionTranslations200Response";
import { CompanyAlternativeNames200Response } from "../model/companyAlternativeNames200Response";
import { CompanyDetails200Response } from "../model/companyDetails200Response";
import { CompanyImages200Response } from "../model/companyImages200Response";
import { ConfigurationDetails200Response } from "../model/configurationDetails200Response";
import { ConfigurationJobs200ResponseInner } from "../model/configurationJobs200ResponseInner";
import { ConfigurationLanguages200ResponseInner } from "../model/configurationLanguages200ResponseInner";
import { ConfigurationTimezones200ResponseInner } from "../model/configurationTimezones200ResponseInner";
import { CreditDetails200Response } from "../model/creditDetails200Response";
import { DetailsCopy200Response } from "../model/detailsCopy200Response";
import { DiscoverMovie200Response } from "../model/discoverMovie200Response";
import { DiscoverTv200Response } from "../model/discoverTv200Response";
import { FindById200Response } from "../model/findById200Response";
import { GenreMovieList200Response } from "../model/genreMovieList200Response";
import { GenreTvList200Response } from "../model/genreTvList200Response";
import { GuestSessionRatedMovies200Response } from "../model/guestSessionRatedMovies200Response";
import { GuestSessionRatedTv200Response } from "../model/guestSessionRatedTv200Response";
import { GuestSessionRatedTvEpisodes200Response } from "../model/guestSessionRatedTvEpisodes200Response";
import { KeywordDetails200Response } from "../model/keywordDetails200Response";
import { KeywordMovies200Response } from "../model/keywordMovies200Response";
import { ListAddMovieRequest } from "../model/listAddMovieRequest";
import { ListCheckItemStatus200Response } from "../model/listCheckItemStatus200Response";
import { ListCreate200Response } from "../model/listCreate200Response";
import { ListDelete200Response } from "../model/listDelete200Response";
import { ListDetails200Response } from "../model/listDetails200Response";
import { ListsCopy200Response } from "../model/listsCopy200Response";
import { MovieAccountStates200Response } from "../model/movieAccountStates200Response";
import { MovieAddRating200Response } from "../model/movieAddRating200Response";
import { MovieAddRatingRequest } from "../model/movieAddRatingRequest";
import { MovieAlternativeTitles200Response } from "../model/movieAlternativeTitles200Response";
import { MovieChanges200Response } from "../model/movieChanges200Response";
import { MovieCredits200Response } from "../model/movieCredits200Response";
import { MovieDeleteRating200Response } from "../model/movieDeleteRating200Response";
import { MovieDetails200Response } from "../model/movieDetails200Response";
import { MovieExternalIds200Response } from "../model/movieExternalIds200Response";
import { MovieImages200Response } from "../model/movieImages200Response";
import { MovieKeywords200Response } from "../model/movieKeywords200Response";
import { MovieLatestId200Response } from "../model/movieLatestId200Response";
import { MovieLists200Response } from "../model/movieLists200Response";
import { MovieNowPlayingList200Response } from "../model/movieNowPlayingList200Response";
import { MoviePopularList200Response } from "../model/moviePopularList200Response";
import { MovieReleaseDates200Response } from "../model/movieReleaseDates200Response";
import { MovieReviews200Response } from "../model/movieReviews200Response";
import { MovieSimilar200Response } from "../model/movieSimilar200Response";
import { MovieTopRatedList200Response } from "../model/movieTopRatedList200Response";
import { MovieTranslations200Response } from "../model/movieTranslations200Response";
import { MovieUpcomingList200Response } from "../model/movieUpcomingList200Response";
import { MovieVideos200Response } from "../model/movieVideos200Response";
import { MovieWatchProviders200Response } from "../model/movieWatchProviders200Response";
import { NetworkDetails200Response } from "../model/networkDetails200Response";
import { PersonChanges200Response } from "../model/personChanges200Response";
import { PersonCombinedCredits200Response } from "../model/personCombinedCredits200Response";
import { PersonDetails200Response } from "../model/personDetails200Response";
import { PersonExternalIds200Response } from "../model/personExternalIds200Response";
import { PersonImages200Response } from "../model/personImages200Response";
import { PersonLatestId200Response } from "../model/personLatestId200Response";
import { PersonMovieCredits200Response } from "../model/personMovieCredits200Response";
import { PersonPopularList200Response } from "../model/personPopularList200Response";
import { PersonTaggedImages200Response } from "../model/personTaggedImages200Response";
import { PersonTvCredits200Response } from "../model/personTvCredits200Response";
import { ReviewDetails200Response } from "../model/reviewDetails200Response";
import { SearchCollection200Response } from "../model/searchCollection200Response";
import { SearchCompany200Response } from "../model/searchCompany200Response";
import { SearchKeyword200Response } from "../model/searchKeyword200Response";
import { SearchMovie200Response } from "../model/searchMovie200Response";
import { SearchMulti200Response } from "../model/searchMulti200Response";
import { SearchPerson200Response } from "../model/searchPerson200Response";
import { SearchTv200Response } from "../model/searchTv200Response";
import { Translations200Response } from "../model/translations200Response";
import { TrendingAll200Response } from "../model/trendingAll200Response";
import { TrendingPeople200Response } from "../model/trendingPeople200Response";
import { TrendingTv200Response } from "../model/trendingTv200Response";
import { TvEpisodeChangesById200Response } from "../model/tvEpisodeChangesById200Response";
import { TvEpisodeCredits200Response } from "../model/tvEpisodeCredits200Response";
import { TvEpisodeDetails200Response } from "../model/tvEpisodeDetails200Response";
import { TvEpisodeExternalIds200Response } from "../model/tvEpisodeExternalIds200Response";
import { TvEpisodeGroupDetails200Response } from "../model/tvEpisodeGroupDetails200Response";
import { TvEpisodeImages200Response } from "../model/tvEpisodeImages200Response";
import { TvEpisodeTranslations200Response } from "../model/tvEpisodeTranslations200Response";
import { TvSeasonAccountStates200Response } from "../model/tvSeasonAccountStates200Response";
import { TvSeasonAggregateCredits200Response } from "../model/tvSeasonAggregateCredits200Response";
import { TvSeasonChangesById200Response } from "../model/tvSeasonChangesById200Response";
import { TvSeasonCredits200Response } from "../model/tvSeasonCredits200Response";
import { TvSeasonDetails200Response } from "../model/tvSeasonDetails200Response";
import { TvSeasonExternalIds200Response } from "../model/tvSeasonExternalIds200Response";
import { TvSeasonImages200Response } from "../model/tvSeasonImages200Response";
import { TvSeasonTranslations200Response } from "../model/tvSeasonTranslations200Response";
import { TvSeasonVideos200Response } from "../model/tvSeasonVideos200Response";
import { TvSeasonWatchProviders200Response } from "../model/tvSeasonWatchProviders200Response";
import { TvSeriesAggregateCredits200Response } from "../model/tvSeriesAggregateCredits200Response";
import { TvSeriesAiringTodayList200Response } from "../model/tvSeriesAiringTodayList200Response";
import { TvSeriesAlternativeTitles200Response } from "../model/tvSeriesAlternativeTitles200Response";
import { TvSeriesChanges200Response } from "../model/tvSeriesChanges200Response";
import { TvSeriesContentRatings200Response } from "../model/tvSeriesContentRatings200Response";
import { TvSeriesCredits200Response } from "../model/tvSeriesCredits200Response";
import { TvSeriesDetails200Response } from "../model/tvSeriesDetails200Response";
import { TvSeriesEpisodeGroups200Response } from "../model/tvSeriesEpisodeGroups200Response";
import { TvSeriesExternalIds200Response } from "../model/tvSeriesExternalIds200Response";
import { TvSeriesKeywords200Response } from "../model/tvSeriesKeywords200Response";
import { TvSeriesLatestId200Response } from "../model/tvSeriesLatestId200Response";
import { TvSeriesOnTheAirList200Response } from "../model/tvSeriesOnTheAirList200Response";
import { TvSeriesPopularList200Response } from "../model/tvSeriesPopularList200Response";
import { TvSeriesRecommendations200Response } from "../model/tvSeriesRecommendations200Response";
import { TvSeriesReviews200Response } from "../model/tvSeriesReviews200Response";
import { TvSeriesScreenedTheatrically200Response } from "../model/tvSeriesScreenedTheatrically200Response";
import { TvSeriesSimilar200Response } from "../model/tvSeriesSimilar200Response";
import { TvSeriesTopRatedList200Response } from "../model/tvSeriesTopRatedList200Response";
import { TvSeriesTranslations200Response } from "../model/tvSeriesTranslations200Response";
import { TvSeriesVideos200Response } from "../model/tvSeriesVideos200Response";
import { TvSeriesWatchProviders200Response } from "../model/tvSeriesWatchProviders200Response";
import { WatchProvidersAvailableRegions200Response } from "../model/watchProvidersAvailableRegions200Response";
import { WatchProvidersAvailableRegions200ResponseResultsInner } from "../model/watchProvidersAvailableRegions200ResponseResultsInner";
import { WatchProvidersMovieList200Response } from "../model/watchProvidersMovieList200Response";

import {
  ObjectSerializer,
  Authentication,
  VoidAuth,
  Interceptor,
} from "../model/models";
import {
  HttpBasicAuth,
  HttpBearerAuth,
  ApiKeyAuth,
  OAuth,
} from "../model/models";

import { HttpError, RequestFile } from "./apis";

let defaultBasePath = "https://api.themoviedb.org";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum DefaultApiApiKeys {
  sec0,
}

export class DefaultApi {
  protected _basePath = defaultBasePath;
  protected _defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    sec0: new ApiKeyAuth("header", "Authorization"),
  };

  protected interceptors: Interceptor[] = [];

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string,
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  set defaultHeaders(defaultHeaders: any) {
    this._defaultHeaders = defaultHeaders;
  }

  get defaultHeaders() {
    return this._defaultHeaders;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: DefaultApiApiKeys, value: string) {
    (this.authentications as any)[DefaultApiApiKeys[key]].apiKey = value;
  }

  public addInterceptor(interceptor: Interceptor) {
    this.interceptors.push(interceptor);
  }

  /**
   *
   * @summary Add Favorite
   * @param accountId
   * @param sessionId
   * @param movieAddRatingRequest
   */
  public async accountAddFavorite(
    accountId: number,
    sessionId?: string,
    movieAddRatingRequest?: MovieAddRatingRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieAddRating200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/account/{account_id}/favorite".replace(
        "{" + "account_id" + "}",
        encodeURIComponent(String(accountId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error(
        "Required parameter accountId was null or undefined when calling accountAddFavorite.",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        movieAddRatingRequest,
        "MovieAddRatingRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieAddRating200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieAddRating200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Add To Watchlist
   * @param accountId
   * @param sessionId
   * @param movieAddRatingRequest
   */
  public async accountAddToWatchlist(
    accountId: number,
    sessionId?: string,
    movieAddRatingRequest?: MovieAddRatingRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieAddRating200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/account/{account_id}/watchlist".replace(
        "{" + "account_id" + "}",
        encodeURIComponent(String(accountId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error(
        "Required parameter accountId was null or undefined when calling accountAddToWatchlist.",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        movieAddRatingRequest,
        "MovieAddRatingRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieAddRating200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieAddRating200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Details
   * @param accountId
   * @param sessionId
   */
  public async accountDetails(
    accountId: number,
    sessionId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AccountDetails200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/account/{account_id}".replace(
        "{" + "account_id" + "}",
        encodeURIComponent(String(accountId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error(
        "Required parameter accountId was null or undefined when calling accountDetails.",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AccountDetails200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AccountDetails200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Favorite TV
   * @param accountId
   * @param language
   * @param page
   * @param sessionId
   * @param sortBy
   */
  public async accountFavoriteTv(
    accountId: number,
    language?: string,
    page?: number,
    sessionId?: string,
    sortBy?: "created_at.asc" | "created_at.desc",
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AccountFavoriteTv200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/account/{account_id}/favorite/tv".replace(
        "{" + "account_id" + "}",
        encodeURIComponent(String(accountId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error(
        "Required parameter accountId was null or undefined when calling accountFavoriteTv.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sort_by"] = ObjectSerializer.serialize(
        sortBy,
        "'created_at.asc' | 'created_at.desc'",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AccountFavoriteTv200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AccountFavoriteTv200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Favorite Movies
   * @param accountId
   * @param language
   * @param page
   * @param sessionId
   * @param sortBy
   */
  public async accountGetFavorites(
    accountId: number,
    language?: string,
    page?: number,
    sessionId?: string,
    sortBy?: "created_at.asc" | "created_at.desc",
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AccountGetFavorites200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/account/{account_id}/favorite/movies".replace(
        "{" + "account_id" + "}",
        encodeURIComponent(String(accountId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error(
        "Required parameter accountId was null or undefined when calling accountGetFavorites.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sort_by"] = ObjectSerializer.serialize(
        sortBy,
        "'created_at.asc' | 'created_at.desc'",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AccountGetFavorites200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AccountGetFavorites200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Lists
   * @param accountId
   * @param page
   * @param sessionId
   */
  public async accountLists(
    accountId: number,
    page?: number,
    sessionId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AccountLists200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/account/{account_id}/lists".replace(
        "{" + "account_id" + "}",
        encodeURIComponent(String(accountId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error(
        "Required parameter accountId was null or undefined when calling accountLists.",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AccountLists200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AccountLists200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Rated Movies
   * @param accountId
   * @param language
   * @param page
   * @param sessionId
   * @param sortBy
   */
  public async accountRatedMovies(
    accountId: number,
    language?: string,
    page?: number,
    sessionId?: string,
    sortBy?: "created_at.asc" | "created_at.desc",
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AccountRatedMovies200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/account/{account_id}/rated/movies".replace(
        "{" + "account_id" + "}",
        encodeURIComponent(String(accountId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error(
        "Required parameter accountId was null or undefined when calling accountRatedMovies.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sort_by"] = ObjectSerializer.serialize(
        sortBy,
        "'created_at.asc' | 'created_at.desc'",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AccountRatedMovies200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AccountRatedMovies200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Rated TV
   * @param accountId
   * @param language
   * @param page
   * @param sessionId
   * @param sortBy
   */
  public async accountRatedTv(
    accountId: number,
    language?: string,
    page?: number,
    sessionId?: string,
    sortBy?: "created_at.asc" | "created_at.desc",
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AccountRatedTv200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/account/{account_id}/rated/tv".replace(
        "{" + "account_id" + "}",
        encodeURIComponent(String(accountId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error(
        "Required parameter accountId was null or undefined when calling accountRatedTv.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sort_by"] = ObjectSerializer.serialize(
        sortBy,
        "'created_at.asc' | 'created_at.desc'",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AccountRatedTv200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AccountRatedTv200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Rated TV Episodes
   * @param accountId
   * @param language
   * @param page
   * @param sessionId
   * @param sortBy
   */
  public async accountRatedTvEpisodes(
    accountId: number,
    language?: string,
    page?: number,
    sessionId?: string,
    sortBy?: "created_at.asc" | "created_at.desc",
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AccountRatedTvEpisodes200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/account/{account_id}/rated/tv/episodes".replace(
        "{" + "account_id" + "}",
        encodeURIComponent(String(accountId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error(
        "Required parameter accountId was null or undefined when calling accountRatedTvEpisodes.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sort_by"] = ObjectSerializer.serialize(
        sortBy,
        "'created_at.asc' | 'created_at.desc'",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AccountRatedTvEpisodes200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AccountRatedTvEpisodes200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Watchlist Movies
   * @param accountId
   * @param language
   * @param page
   * @param sessionId
   * @param sortBy
   */
  public async accountWatchlistMovies(
    accountId: number,
    language?: string,
    page?: number,
    sessionId?: string,
    sortBy?: "created_at.asc" | "created_at.desc",
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AccountWatchlistMovies200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/account/{account_id}/watchlist/movies".replace(
        "{" + "account_id" + "}",
        encodeURIComponent(String(accountId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error(
        "Required parameter accountId was null or undefined when calling accountWatchlistMovies.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sort_by"] = ObjectSerializer.serialize(
        sortBy,
        "'created_at.asc' | 'created_at.desc'",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AccountWatchlistMovies200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AccountWatchlistMovies200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Watchlist TV
   * @param accountId
   * @param language
   * @param page
   * @param sessionId
   * @param sortBy
   */
  public async accountWatchlistTv(
    accountId: number,
    language?: string,
    page?: number,
    sessionId?: string,
    sortBy?: "created_at.asc" | "created_at.desc",
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AccountWatchlistTv200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/account/{account_id}/watchlist/tv".replace(
        "{" + "account_id" + "}",
        encodeURIComponent(String(accountId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'accountId' is not null or undefined
    if (accountId === null || accountId === undefined) {
      throw new Error(
        "Required parameter accountId was null or undefined when calling accountWatchlistTv.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sort_by"] = ObjectSerializer.serialize(
        sortBy,
        "'created_at.asc' | 'created_at.desc'",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AccountWatchlistTv200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AccountWatchlistTv200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the TV network logos by id.
   * @summary Images
   * @param networkId
   */
  public async alternativeNamesCopy(
    networkId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AlternativeNamesCopy200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/network/{network_id}/images".replace(
        "{" + "network_id" + "}",
        encodeURIComponent(String(networkId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'networkId' is not null or undefined
    if (networkId === null || networkId === undefined) {
      throw new Error(
        "Required parameter networkId was null or undefined when calling alternativeNamesCopy.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AlternativeNamesCopy200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AlternativeNamesCopy200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Create Guest Session
   */
  public async authenticationCreateGuestSession(
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AuthenticationCreateGuestSession200Response;
  }> {
    const localVarPath = this.basePath + "/3/authentication/guest_session/new";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AuthenticationCreateGuestSession200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AuthenticationCreateGuestSession200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Create Request Token
   */
  public async authenticationCreateRequestToken(
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AuthenticationCreateRequestToken200Response;
  }> {
    const localVarPath = this.basePath + "/3/authentication/token/new";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AuthenticationCreateRequestToken200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AuthenticationCreateRequestToken200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Create Session
   * @param movieAddRatingRequest
   */
  public async authenticationCreateSession(
    movieAddRatingRequest?: MovieAddRatingRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AuthenticationCreateSession200Response;
  }> {
    const localVarPath = this.basePath + "/3/authentication/session/new";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        movieAddRatingRequest,
        "MovieAddRatingRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AuthenticationCreateSession200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AuthenticationCreateSession200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * This method allows an application to validate a request token by entering a username and password.
   * @summary Create Session (with login)
   * @param movieAddRatingRequest
   */
  public async authenticationCreateSessionFromLogin(
    movieAddRatingRequest?: MovieAddRatingRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AuthenticationCreateSessionFromLogin200Response;
  }> {
    const localVarPath =
      this.basePath + "/3/authentication/token/validate_with_login";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        movieAddRatingRequest,
        "MovieAddRatingRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AuthenticationCreateSessionFromLogin200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AuthenticationCreateSessionFromLogin200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Create Session (from v4 token)
   * @param movieAddRatingRequest
   */
  public async authenticationCreateSessionFromV4Token(
    movieAddRatingRequest?: MovieAddRatingRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AuthenticationCreateSessionFromV4Token200Response;
  }> {
    const localVarPath = this.basePath + "/3/authentication/session/convert/4";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        movieAddRatingRequest,
        "MovieAddRatingRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AuthenticationCreateSessionFromV4Token200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AuthenticationCreateSessionFromV4Token200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Delete Session
   * @param movieAddRatingRequest
   */
  public async authenticationDeleteSession(
    movieAddRatingRequest?: MovieAddRatingRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AuthenticationDeleteSession200Response;
  }> {
    const localVarPath = this.basePath + "/3/authentication/session";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        movieAddRatingRequest,
        "MovieAddRatingRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AuthenticationDeleteSession200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AuthenticationDeleteSession200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Test your API Key to see if it\'s valid.
   * @summary Validate Key
   */
  public async authenticationValidateKey(
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AuthenticationValidateKey200Response;
  }> {
    const localVarPath = this.basePath + "/3/authentication";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AuthenticationValidateKey200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AuthenticationValidateKey200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get an up to date list of the officially supported movie certifications on TMDB.
   * @summary Movie Certifications
   */
  public async certificationMovieList(
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: CertificationMovieList200Response;
  }> {
    const localVarPath = this.basePath + "/3/certification/movie/list";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CertificationMovieList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "CertificationMovieList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary TV Certifications
   */
  public async certificationsTvList(
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: CertificationsTvList200Response;
  }> {
    const localVarPath = this.basePath + "/3/certification/tv/list";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CertificationsTvList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "CertificationsTvList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a list of all of the movie ids that have been changed in the past 24 hours.
   * @summary Movie List
   * @param endDate
   * @param page
   * @param startDate
   */
  public async changesMovieList(
    endDate?: string,
    page?: number,
    startDate?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: ChangesMovieList200Response;
  }> {
    const localVarPath = this.basePath + "/3/movie/changes";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (endDate !== undefined) {
      localVarQueryParameters["end_date"] = ObjectSerializer.serialize(
        endDate,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["start_date"] = ObjectSerializer.serialize(
        startDate,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ChangesMovieList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "ChangesMovieList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary People List
   * @param endDate
   * @param page
   * @param startDate
   */
  public async changesPeopleList(
    endDate?: string,
    page?: number,
    startDate?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: ChangesPeopleList200Response;
  }> {
    const localVarPath = this.basePath + "/3/person/changes";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (endDate !== undefined) {
      localVarQueryParameters["end_date"] = ObjectSerializer.serialize(
        endDate,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["start_date"] = ObjectSerializer.serialize(
        startDate,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ChangesPeopleList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "ChangesPeopleList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary TV List
   * @param endDate
   * @param page
   * @param startDate
   */
  public async changesTvList(
    endDate?: string,
    page?: number,
    startDate?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: ChangesTvList200Response;
  }> {
    const localVarPath = this.basePath + "/3/tv/changes";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (endDate !== undefined) {
      localVarQueryParameters["end_date"] = ObjectSerializer.serialize(
        endDate,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["start_date"] = ObjectSerializer.serialize(
        startDate,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ChangesTvList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "ChangesTvList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get collection details by ID.
   * @summary Details
   * @param collectionId
   * @param language
   */
  public async collectionDetails(
    collectionId: number,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: CollectionDetails200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/collection/{collection_id}".replace(
        "{" + "collection_id" + "}",
        encodeURIComponent(String(collectionId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'collectionId' is not null or undefined
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        "Required parameter collectionId was null or undefined when calling collectionDetails.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CollectionDetails200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "CollectionDetails200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the images that belong to a collection.
   * @summary Images
   * @param collectionId
   * @param includeImageLanguage specify a comma separated list of ISO-639-1 values to query, for example: &#x60;en,null&#x60;
   * @param language
   */
  public async collectionImages(
    collectionId: number,
    includeImageLanguage?: string,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: CollectionImages200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/collection/{collection_id}/images".replace(
        "{" + "collection_id" + "}",
        encodeURIComponent(String(collectionId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'collectionId' is not null or undefined
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        "Required parameter collectionId was null or undefined when calling collectionImages.",
      );
    }

    if (includeImageLanguage !== undefined) {
      localVarQueryParameters["include_image_language"] =
        ObjectSerializer.serialize(includeImageLanguage, "string");
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CollectionImages200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "CollectionImages200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Translations
   * @param collectionId
   */
  public async collectionTranslations(
    collectionId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: CollectionTranslations200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/collection/{collection_id}/translations".replace(
        "{" + "collection_id" + "}",
        encodeURIComponent(String(collectionId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'collectionId' is not null or undefined
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        "Required parameter collectionId was null or undefined when calling collectionTranslations.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CollectionTranslations200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "CollectionTranslations200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the company details by ID.
   * @summary Alternative Names
   * @param companyId
   */
  public async companyAlternativeNames(
    companyId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: CompanyAlternativeNames200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/company/{company_id}/alternative_names".replace(
        "{" + "company_id" + "}",
        encodeURIComponent(String(companyId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'companyId' is not null or undefined
    if (companyId === null || companyId === undefined) {
      throw new Error(
        "Required parameter companyId was null or undefined when calling companyAlternativeNames.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CompanyAlternativeNames200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "CompanyAlternativeNames200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the company details by ID.
   * @summary Details
   * @param companyId
   */
  public async companyDetails(
    companyId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: CompanyDetails200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/company/{company_id}".replace(
        "{" + "company_id" + "}",
        encodeURIComponent(String(companyId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'companyId' is not null or undefined
    if (companyId === null || companyId === undefined) {
      throw new Error(
        "Required parameter companyId was null or undefined when calling companyDetails.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CompanyDetails200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "CompanyDetails200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the company logos by id.
   * @summary Images
   * @param companyId
   */
  public async companyImages(
    companyId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: CompanyImages200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/company/{company_id}/images".replace(
        "{" + "company_id" + "}",
        encodeURIComponent(String(companyId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'companyId' is not null or undefined
    if (companyId === null || companyId === undefined) {
      throw new Error(
        "Required parameter companyId was null or undefined when calling companyImages.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CompanyImages200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "CompanyImages200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the list of countries (ISO 3166-1 tags) used throughout TMDB.
   * @summary Countries
   * @param language
   */
  public async configurationCountries(
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: Array<WatchProvidersAvailableRegions200ResponseResultsInner>;
  }> {
    const localVarPath = this.basePath + "/3/configuration/countries";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: Array<WatchProvidersAvailableRegions200ResponseResultsInner>;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "Array<WatchProvidersAvailableRegions200ResponseResultsInner>",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Query the API configuration details.
   * @summary Details
   */
  public async configurationDetails(
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: ConfigurationDetails200Response;
  }> {
    const localVarPath = this.basePath + "/3/configuration";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ConfigurationDetails200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "ConfigurationDetails200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the list of the jobs and departments we use on TMDB.
   * @summary Jobs
   */
  public async configurationJobs(
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: Array<ConfigurationJobs200ResponseInner>;
  }> {
    const localVarPath = this.basePath + "/3/configuration/jobs";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: Array<ConfigurationJobs200ResponseInner>;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "Array<ConfigurationJobs200ResponseInner>",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the list of languages (ISO 639-1 tags) used throughout TMDB.
   * @summary Languages
   */
  public async configurationLanguages(
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: Array<ConfigurationLanguages200ResponseInner>;
  }> {
    const localVarPath = this.basePath + "/3/configuration/languages";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: Array<ConfigurationLanguages200ResponseInner>;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "Array<ConfigurationLanguages200ResponseInner>",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a list of the officially supported translations on TMDB.
   * @summary Primary Translations
   */
  public async configurationPrimaryTranslations(
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: Array<string> }> {
    const localVarPath =
      this.basePath + "/3/configuration/primary_translations";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: Array<string>;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, "Array<string>");
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the list of timezones used throughout TMDB.
   * @summary Timezones
   */
  public async configurationTimezones(
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: Array<ConfigurationTimezones200ResponseInner>;
  }> {
    const localVarPath = this.basePath + "/3/configuration/timezones";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: Array<ConfigurationTimezones200ResponseInner>;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "Array<ConfigurationTimezones200ResponseInner>",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a movie or TV credit details by ID.
   * @summary Details
   * @param creditId
   */
  public async creditDetails(
    creditId: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: CreditDetails200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/credit/{credit_id}".replace(
        "{" + "credit_id" + "}",
        encodeURIComponent(String(creditId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'creditId' is not null or undefined
    if (creditId === null || creditId === undefined) {
      throw new Error(
        "Required parameter creditId was null or undefined when calling creditDetails.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreditDetails200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "CreditDetails200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the alternative names of a network.
   * @summary Alternative Names
   * @param networkId
   */
  public async detailsCopy(
    networkId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: DetailsCopy200Response }> {
    const localVarPath =
      this.basePath +
      "/3/network/{network_id}/alternative_names".replace(
        "{" + "network_id" + "}",
        encodeURIComponent(String(networkId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'networkId' is not null or undefined
    if (networkId === null || networkId === undefined) {
      throw new Error(
        "Required parameter networkId was null or undefined when calling detailsCopy.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DetailsCopy200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "DetailsCopy200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Find movies using over 30 filters and sort options.
   * @summary Movie
   * @param certification use in conjunction with &#x60;region&#x60;
   * @param certificationGte use in conjunction with &#x60;region&#x60;
   * @param certificationLte use in conjunction with &#x60;region&#x60;
   * @param certificationCountry use in conjunction with the &#x60;certification&#x60;, &#x60;certification.gte&#x60; and &#x60;certification.lte&#x60; filters
   * @param includeAdult
   * @param includeVideo
   * @param language
   * @param page
   * @param primaryReleaseYear
   * @param primaryReleaseDateGte
   * @param primaryReleaseDateLte
   * @param region
   * @param releaseDateGte
   * @param releaseDateLte
   * @param sortBy
   * @param voteAverageGte
   * @param voteAverageLte
   * @param voteCountGte
   * @param voteCountLte
   * @param watchRegion use in conjunction with &#x60;with_watch_monetization_types &#x60; or &#x60;with_watch_providers &#x60;
   * @param withCast can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query
   * @param withCompanies can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query
   * @param withCrew can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query
   * @param withGenres can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query
   * @param withKeywords can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query
   * @param withOriginCountry
   * @param withOriginalLanguage
   * @param withPeople can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query
   * @param withReleaseType possible values are: [1, 2, 3, 4, 5, 6] can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query, can be used in conjunction with &#x60;region&#x60;
   * @param withRuntimeGte
   * @param withRuntimeLte
   * @param withWatchMonetizationTypes possible values are: [flatrate, free, ads, rent, buy] use in conjunction with &#x60;watch_region&#x60;, can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query
   * @param withWatchProviders use in conjunction with &#x60;watch_region&#x60;, can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query
   * @param withoutCompanies
   * @param withoutGenres
   * @param withoutKeywords
   * @param withoutWatchProviders
   * @param year
   */
  public async discoverMovie(
    certification?: string,
    certificationGte?: string,
    certificationLte?: string,
    certificationCountry?: string,
    includeAdult?: boolean,
    includeVideo?: boolean,
    language?: string,
    page?: number,
    primaryReleaseYear?: number,
    primaryReleaseDateGte?: string,
    primaryReleaseDateLte?: string,
    region?: string,
    releaseDateGte?: string,
    releaseDateLte?: string,
    sortBy?:
      | "original_title.asc"
      | "original_title.desc"
      | "popularity.asc"
      | "popularity.desc"
      | "revenue.asc"
      | "revenue.desc"
      | "primary_release_date.asc"
      | "title.asc"
      | "title.desc"
      | "primary_release_date.desc"
      | "vote_average.asc"
      | "vote_average.desc"
      | "vote_count.asc"
      | "vote_count.desc",
    voteAverageGte?: number,
    voteAverageLte?: number,
    voteCountGte?: number,
    voteCountLte?: number,
    watchRegion?: string,
    withCast?: string,
    withCompanies?: string,
    withCrew?: string,
    withGenres?: string,
    withKeywords?: string,
    withOriginCountry?: string,
    withOriginalLanguage?: string,
    withPeople?: string,
    withReleaseType?: number,
    withRuntimeGte?: number,
    withRuntimeLte?: number,
    withWatchMonetizationTypes?: string,
    withWatchProviders?: string,
    withoutCompanies?: string,
    withoutGenres?: string,
    withoutKeywords?: string,
    withoutWatchProviders?: string,
    year?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: DiscoverMovie200Response;
  }> {
    const localVarPath = this.basePath + "/3/discover/movie";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (certification !== undefined) {
      localVarQueryParameters["certification"] = ObjectSerializer.serialize(
        certification,
        "string",
      );
    }

    if (certificationGte !== undefined) {
      localVarQueryParameters["certification.gte"] = ObjectSerializer.serialize(
        certificationGte,
        "string",
      );
    }

    if (certificationLte !== undefined) {
      localVarQueryParameters["certification.lte"] = ObjectSerializer.serialize(
        certificationLte,
        "string",
      );
    }

    if (certificationCountry !== undefined) {
      localVarQueryParameters["certification_country"] =
        ObjectSerializer.serialize(certificationCountry, "string");
    }

    if (includeAdult !== undefined) {
      localVarQueryParameters["include_adult"] = ObjectSerializer.serialize(
        includeAdult,
        "boolean",
      );
    }

    if (includeVideo !== undefined) {
      localVarQueryParameters["include_video"] = ObjectSerializer.serialize(
        includeVideo,
        "boolean",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (primaryReleaseYear !== undefined) {
      localVarQueryParameters["primary_release_year"] =
        ObjectSerializer.serialize(primaryReleaseYear, "number");
    }

    if (primaryReleaseDateGte !== undefined) {
      localVarQueryParameters["primary_release_date.gte"] =
        ObjectSerializer.serialize(primaryReleaseDateGte, "string");
    }

    if (primaryReleaseDateLte !== undefined) {
      localVarQueryParameters["primary_release_date.lte"] =
        ObjectSerializer.serialize(primaryReleaseDateLte, "string");
    }

    if (region !== undefined) {
      localVarQueryParameters["region"] = ObjectSerializer.serialize(
        region,
        "string",
      );
    }

    if (releaseDateGte !== undefined) {
      localVarQueryParameters["release_date.gte"] = ObjectSerializer.serialize(
        releaseDateGte,
        "string",
      );
    }

    if (releaseDateLte !== undefined) {
      localVarQueryParameters["release_date.lte"] = ObjectSerializer.serialize(
        releaseDateLte,
        "string",
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sort_by"] = ObjectSerializer.serialize(
        sortBy,
        "'original_title.asc' | 'original_title.desc' | 'popularity.asc' | 'popularity.desc' | 'revenue.asc' | 'revenue.desc' | 'primary_release_date.asc' | 'title.asc' | 'title.desc' | 'primary_release_date.desc' | 'vote_average.asc' | 'vote_average.desc' | 'vote_count.asc' | 'vote_count.desc'",
      );
    }

    if (voteAverageGte !== undefined) {
      localVarQueryParameters["vote_average.gte"] = ObjectSerializer.serialize(
        voteAverageGte,
        "number",
      );
    }

    if (voteAverageLte !== undefined) {
      localVarQueryParameters["vote_average.lte"] = ObjectSerializer.serialize(
        voteAverageLte,
        "number",
      );
    }

    if (voteCountGte !== undefined) {
      localVarQueryParameters["vote_count.gte"] = ObjectSerializer.serialize(
        voteCountGte,
        "number",
      );
    }

    if (voteCountLte !== undefined) {
      localVarQueryParameters["vote_count.lte"] = ObjectSerializer.serialize(
        voteCountLte,
        "number",
      );
    }

    if (watchRegion !== undefined) {
      localVarQueryParameters["watch_region"] = ObjectSerializer.serialize(
        watchRegion,
        "string",
      );
    }

    if (withCast !== undefined) {
      localVarQueryParameters["with_cast"] = ObjectSerializer.serialize(
        withCast,
        "string",
      );
    }

    if (withCompanies !== undefined) {
      localVarQueryParameters["with_companies"] = ObjectSerializer.serialize(
        withCompanies,
        "string",
      );
    }

    if (withCrew !== undefined) {
      localVarQueryParameters["with_crew"] = ObjectSerializer.serialize(
        withCrew,
        "string",
      );
    }

    if (withGenres !== undefined) {
      localVarQueryParameters["with_genres"] = ObjectSerializer.serialize(
        withGenres,
        "string",
      );
    }

    if (withKeywords !== undefined) {
      localVarQueryParameters["with_keywords"] = ObjectSerializer.serialize(
        withKeywords,
        "string",
      );
    }

    if (withOriginCountry !== undefined) {
      localVarQueryParameters["with_origin_country"] =
        ObjectSerializer.serialize(withOriginCountry, "string");
    }

    if (withOriginalLanguage !== undefined) {
      localVarQueryParameters["with_original_language"] =
        ObjectSerializer.serialize(withOriginalLanguage, "string");
    }

    if (withPeople !== undefined) {
      localVarQueryParameters["with_people"] = ObjectSerializer.serialize(
        withPeople,
        "string",
      );
    }

    if (withReleaseType !== undefined) {
      localVarQueryParameters["with_release_type"] = ObjectSerializer.serialize(
        withReleaseType,
        "number",
      );
    }

    if (withRuntimeGte !== undefined) {
      localVarQueryParameters["with_runtime.gte"] = ObjectSerializer.serialize(
        withRuntimeGte,
        "number",
      );
    }

    if (withRuntimeLte !== undefined) {
      localVarQueryParameters["with_runtime.lte"] = ObjectSerializer.serialize(
        withRuntimeLte,
        "number",
      );
    }

    if (withWatchMonetizationTypes !== undefined) {
      localVarQueryParameters["with_watch_monetization_types"] =
        ObjectSerializer.serialize(withWatchMonetizationTypes, "string");
    }

    if (withWatchProviders !== undefined) {
      localVarQueryParameters["with_watch_providers"] =
        ObjectSerializer.serialize(withWatchProviders, "string");
    }

    if (withoutCompanies !== undefined) {
      localVarQueryParameters["without_companies"] = ObjectSerializer.serialize(
        withoutCompanies,
        "string",
      );
    }

    if (withoutGenres !== undefined) {
      localVarQueryParameters["without_genres"] = ObjectSerializer.serialize(
        withoutGenres,
        "string",
      );
    }

    if (withoutKeywords !== undefined) {
      localVarQueryParameters["without_keywords"] = ObjectSerializer.serialize(
        withoutKeywords,
        "string",
      );
    }

    if (withoutWatchProviders !== undefined) {
      localVarQueryParameters["without_watch_providers"] =
        ObjectSerializer.serialize(withoutWatchProviders, "string");
    }

    if (year !== undefined) {
      localVarQueryParameters["year"] = ObjectSerializer.serialize(
        year,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DiscoverMovie200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "DiscoverMovie200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Find TV shows using over 30 filters and sort options.
   * @summary TV
   * @param airDateGte
   * @param airDateLte
   * @param firstAirDateYear
   * @param firstAirDateGte
   * @param firstAirDateLte
   * @param includeAdult
   * @param includeNullFirstAirDates
   * @param language
   * @param page
   * @param screenedTheatrically
   * @param sortBy
   * @param timezone
   * @param voteAverageGte
   * @param voteAverageLte
   * @param voteCountGte
   * @param voteCountLte
   * @param watchRegion use in conjunction with &#x60;with_watch_monetization_types &#x60; or &#x60;with_watch_providers &#x60;
   * @param withCompanies can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query
   * @param withGenres can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query
   * @param withKeywords can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query
   * @param withNetworks
   * @param withOriginCountry
   * @param withOriginalLanguage
   * @param withRuntimeGte
   * @param withRuntimeLte
   * @param withStatus possible values are: [0, 1, 2, 3, 4, 5], can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query
   * @param withWatchMonetizationTypes possible values are: [flatrate, free, ads, rent, buy] use in conjunction with &#x60;watch_region&#x60;, can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query
   * @param withWatchProviders use in conjunction with &#x60;watch_region&#x60;, can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query
   * @param withoutCompanies
   * @param withoutGenres
   * @param withoutKeywords
   * @param withoutWatchProviders
   * @param withType possible values are: [0, 1, 2, 3, 4, 5, 6], can be a comma (&#x60;AND&#x60;) or pipe (&#x60;OR&#x60;) separated query
   */
  public async discoverTv(
    airDateGte?: string,
    airDateLte?: string,
    firstAirDateYear?: number,
    firstAirDateGte?: string,
    firstAirDateLte?: string,
    includeAdult?: boolean,
    includeNullFirstAirDates?: boolean,
    language?: string,
    page?: number,
    screenedTheatrically?: boolean,
    sortBy?:
      | "first_air_date.asc"
      | "first_air_date.desc"
      | "name.asc"
      | "name.desc"
      | "original_name.asc"
      | "original_name.desc"
      | "popularity.asc"
      | "popularity.desc"
      | "vote_average.asc"
      | "vote_average.desc"
      | "vote_count.asc"
      | "vote_count.desc",
    timezone?: string,
    voteAverageGte?: number,
    voteAverageLte?: number,
    voteCountGte?: number,
    voteCountLte?: number,
    watchRegion?: string,
    withCompanies?: string,
    withGenres?: string,
    withKeywords?: string,
    withNetworks?: number,
    withOriginCountry?: string,
    withOriginalLanguage?: string,
    withRuntimeGte?: number,
    withRuntimeLte?: number,
    withStatus?: string,
    withWatchMonetizationTypes?: string,
    withWatchProviders?: string,
    withoutCompanies?: string,
    withoutGenres?: string,
    withoutKeywords?: string,
    withoutWatchProviders?: string,
    withType?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: DiscoverTv200Response }> {
    const localVarPath = this.basePath + "/3/discover/tv";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (airDateGte !== undefined) {
      localVarQueryParameters["air_date.gte"] = ObjectSerializer.serialize(
        airDateGte,
        "string",
      );
    }

    if (airDateLte !== undefined) {
      localVarQueryParameters["air_date.lte"] = ObjectSerializer.serialize(
        airDateLte,
        "string",
      );
    }

    if (firstAirDateYear !== undefined) {
      localVarQueryParameters["first_air_date_year"] =
        ObjectSerializer.serialize(firstAirDateYear, "number");
    }

    if (firstAirDateGte !== undefined) {
      localVarQueryParameters["first_air_date.gte"] =
        ObjectSerializer.serialize(firstAirDateGte, "string");
    }

    if (firstAirDateLte !== undefined) {
      localVarQueryParameters["first_air_date.lte"] =
        ObjectSerializer.serialize(firstAirDateLte, "string");
    }

    if (includeAdult !== undefined) {
      localVarQueryParameters["include_adult"] = ObjectSerializer.serialize(
        includeAdult,
        "boolean",
      );
    }

    if (includeNullFirstAirDates !== undefined) {
      localVarQueryParameters["include_null_first_air_dates"] =
        ObjectSerializer.serialize(includeNullFirstAirDates, "boolean");
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (screenedTheatrically !== undefined) {
      localVarQueryParameters["screened_theatrically"] =
        ObjectSerializer.serialize(screenedTheatrically, "boolean");
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sort_by"] = ObjectSerializer.serialize(
        sortBy,
        "'first_air_date.asc' | 'first_air_date.desc' | 'name.asc' | 'name.desc' | 'original_name.asc' | 'original_name.desc' | 'popularity.asc' | 'popularity.desc' | 'vote_average.asc' | 'vote_average.desc' | 'vote_count.asc' | 'vote_count.desc'",
      );
    }

    if (timezone !== undefined) {
      localVarQueryParameters["timezone"] = ObjectSerializer.serialize(
        timezone,
        "string",
      );
    }

    if (voteAverageGte !== undefined) {
      localVarQueryParameters["vote_average.gte"] = ObjectSerializer.serialize(
        voteAverageGte,
        "number",
      );
    }

    if (voteAverageLte !== undefined) {
      localVarQueryParameters["vote_average.lte"] = ObjectSerializer.serialize(
        voteAverageLte,
        "number",
      );
    }

    if (voteCountGte !== undefined) {
      localVarQueryParameters["vote_count.gte"] = ObjectSerializer.serialize(
        voteCountGte,
        "number",
      );
    }

    if (voteCountLte !== undefined) {
      localVarQueryParameters["vote_count.lte"] = ObjectSerializer.serialize(
        voteCountLte,
        "number",
      );
    }

    if (watchRegion !== undefined) {
      localVarQueryParameters["watch_region"] = ObjectSerializer.serialize(
        watchRegion,
        "string",
      );
    }

    if (withCompanies !== undefined) {
      localVarQueryParameters["with_companies"] = ObjectSerializer.serialize(
        withCompanies,
        "string",
      );
    }

    if (withGenres !== undefined) {
      localVarQueryParameters["with_genres"] = ObjectSerializer.serialize(
        withGenres,
        "string",
      );
    }

    if (withKeywords !== undefined) {
      localVarQueryParameters["with_keywords"] = ObjectSerializer.serialize(
        withKeywords,
        "string",
      );
    }

    if (withNetworks !== undefined) {
      localVarQueryParameters["with_networks"] = ObjectSerializer.serialize(
        withNetworks,
        "number",
      );
    }

    if (withOriginCountry !== undefined) {
      localVarQueryParameters["with_origin_country"] =
        ObjectSerializer.serialize(withOriginCountry, "string");
    }

    if (withOriginalLanguage !== undefined) {
      localVarQueryParameters["with_original_language"] =
        ObjectSerializer.serialize(withOriginalLanguage, "string");
    }

    if (withRuntimeGte !== undefined) {
      localVarQueryParameters["with_runtime.gte"] = ObjectSerializer.serialize(
        withRuntimeGte,
        "number",
      );
    }

    if (withRuntimeLte !== undefined) {
      localVarQueryParameters["with_runtime.lte"] = ObjectSerializer.serialize(
        withRuntimeLte,
        "number",
      );
    }

    if (withStatus !== undefined) {
      localVarQueryParameters["with_status"] = ObjectSerializer.serialize(
        withStatus,
        "string",
      );
    }

    if (withWatchMonetizationTypes !== undefined) {
      localVarQueryParameters["with_watch_monetization_types"] =
        ObjectSerializer.serialize(withWatchMonetizationTypes, "string");
    }

    if (withWatchProviders !== undefined) {
      localVarQueryParameters["with_watch_providers"] =
        ObjectSerializer.serialize(withWatchProviders, "string");
    }

    if (withoutCompanies !== undefined) {
      localVarQueryParameters["without_companies"] = ObjectSerializer.serialize(
        withoutCompanies,
        "string",
      );
    }

    if (withoutGenres !== undefined) {
      localVarQueryParameters["without_genres"] = ObjectSerializer.serialize(
        withoutGenres,
        "string",
      );
    }

    if (withoutKeywords !== undefined) {
      localVarQueryParameters["without_keywords"] = ObjectSerializer.serialize(
        withoutKeywords,
        "string",
      );
    }

    if (withoutWatchProviders !== undefined) {
      localVarQueryParameters["without_watch_providers"] =
        ObjectSerializer.serialize(withoutWatchProviders, "string");
    }

    if (withType !== undefined) {
      localVarQueryParameters["with_type"] = ObjectSerializer.serialize(
        withType,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DiscoverTv200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "DiscoverTv200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Find data by external ID\'s.
   * @summary Find By ID
   * @param externalId
   * @param externalSource
   * @param language
   */
  public async findById(
    externalId: string,
    externalSource:
      | ""
      | "imdb_id"
      | "facebook_id"
      | "instagram_id"
      | "tvdb_id"
      | "tiktok_id"
      | "twitter_id"
      | "wikidata_id"
      | "youtube_id",
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: FindById200Response }> {
    const localVarPath =
      this.basePath +
      "/3/find/{external_id}".replace(
        "{" + "external_id" + "}",
        encodeURIComponent(String(externalId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'externalId' is not null or undefined
    if (externalId === null || externalId === undefined) {
      throw new Error(
        "Required parameter externalId was null or undefined when calling findById.",
      );
    }

    // verify required parameter 'externalSource' is not null or undefined
    if (externalSource === null || externalSource === undefined) {
      throw new Error(
        "Required parameter externalSource was null or undefined when calling findById.",
      );
    }

    if (externalSource !== undefined) {
      localVarQueryParameters["external_source"] = ObjectSerializer.serialize(
        externalSource,
        "'' | 'imdb_id' | 'facebook_id' | 'instagram_id' | 'tvdb_id' | 'tiktok_id' | 'twitter_id' | 'wikidata_id' | 'youtube_id'",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: FindById200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, "FindById200Response");
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the list of official genres for movies.
   * @summary Movie List
   * @param language
   */
  public async genreMovieList(
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: GenreMovieList200Response;
  }> {
    const localVarPath = this.basePath + "/3/genre/movie/list";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GenreMovieList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "GenreMovieList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the list of official genres for TV shows.
   * @summary TV List
   * @param language
   */
  public async genreTvList(
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: GenreTvList200Response }> {
    const localVarPath = this.basePath + "/3/genre/tv/list";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GenreTvList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "GenreTvList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the rated movies for a guest session.
   * @summary Rated Movies
   * @param guestSessionId
   * @param language
   * @param page
   * @param sortBy
   */
  public async guestSessionRatedMovies(
    guestSessionId: string,
    language?: string,
    page?: number,
    sortBy?: "created_at.asc" | "created_at.desc",
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: GuestSessionRatedMovies200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/guest_session/{guest_session_id}/rated/movies".replace(
        "{" + "guest_session_id" + "}",
        encodeURIComponent(String(guestSessionId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'guestSessionId' is not null or undefined
    if (guestSessionId === null || guestSessionId === undefined) {
      throw new Error(
        "Required parameter guestSessionId was null or undefined when calling guestSessionRatedMovies.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sort_by"] = ObjectSerializer.serialize(
        sortBy,
        "'created_at.asc' | 'created_at.desc'",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GuestSessionRatedMovies200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "GuestSessionRatedMovies200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the rated TV shows for a guest session.
   * @summary Rated TV
   * @param guestSessionId
   * @param language
   * @param page
   * @param sortBy
   */
  public async guestSessionRatedTv(
    guestSessionId: string,
    language?: string,
    page?: number,
    sortBy?: "created_at.asc" | "created_at.desc",
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: GuestSessionRatedTv200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/guest_session/{guest_session_id}/rated/tv".replace(
        "{" + "guest_session_id" + "}",
        encodeURIComponent(String(guestSessionId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'guestSessionId' is not null or undefined
    if (guestSessionId === null || guestSessionId === undefined) {
      throw new Error(
        "Required parameter guestSessionId was null or undefined when calling guestSessionRatedTv.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sort_by"] = ObjectSerializer.serialize(
        sortBy,
        "'created_at.asc' | 'created_at.desc'",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GuestSessionRatedTv200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "GuestSessionRatedTv200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the rated TV episodes for a guest session.
   * @summary Rated TV Episodes
   * @param guestSessionId
   * @param language
   * @param page
   * @param sortBy
   */
  public async guestSessionRatedTvEpisodes(
    guestSessionId: string,
    language?: string,
    page?: number,
    sortBy?: "created_at.asc" | "created_at.desc",
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: GuestSessionRatedTvEpisodes200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/guest_session/{guest_session_id}/rated/tv/episodes".replace(
        "{" + "guest_session_id" + "}",
        encodeURIComponent(String(guestSessionId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'guestSessionId' is not null or undefined
    if (guestSessionId === null || guestSessionId === undefined) {
      throw new Error(
        "Required parameter guestSessionId was null or undefined when calling guestSessionRatedTvEpisodes.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sort_by"] = ObjectSerializer.serialize(
        sortBy,
        "'created_at.asc' | 'created_at.desc'",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GuestSessionRatedTvEpisodes200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "GuestSessionRatedTvEpisodes200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Details
   * @param keywordId
   */
  public async keywordDetails(
    keywordId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: KeywordDetails200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/keyword/{keyword_id}".replace(
        "{" + "keyword_id" + "}",
        encodeURIComponent(String(keywordId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'keywordId' is not null or undefined
    if (keywordId === null || keywordId === undefined) {
      throw new Error(
        "Required parameter keywordId was null or undefined when calling keywordDetails.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: KeywordDetails200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "KeywordDetails200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Movies
   * @param keywordId
   * @param includeAdult
   * @param language
   * @param page
   */
  public async keywordMovies(
    keywordId: string,
    includeAdult?: boolean,
    language?: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: KeywordMovies200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/keyword/{keyword_id}/movies".replace(
        "{" + "keyword_id" + "}",
        encodeURIComponent(String(keywordId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'keywordId' is not null or undefined
    if (keywordId === null || keywordId === undefined) {
      throw new Error(
        "Required parameter keywordId was null or undefined when calling keywordMovies.",
      );
    }

    if (includeAdult !== undefined) {
      localVarQueryParameters["include_adult"] = ObjectSerializer.serialize(
        includeAdult,
        "boolean",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: KeywordMovies200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "KeywordMovies200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Add a movie to a list.
   * @summary Add Movie
   * @param listId
   * @param sessionId
   * @param listAddMovieRequest
   */
  public async listAddMovie(
    listId: number,
    sessionId: string,
    listAddMovieRequest?: ListAddMovieRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: ListDelete200Response }> {
    const localVarPath =
      this.basePath +
      "/3/list/{list_id}/add_item".replace(
        "{" + "list_id" + "}",
        encodeURIComponent(String(listId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'listId' is not null or undefined
    if (listId === null || listId === undefined) {
      throw new Error(
        "Required parameter listId was null or undefined when calling listAddMovie.",
      );
    }

    // verify required parameter 'sessionId' is not null or undefined
    if (sessionId === null || sessionId === undefined) {
      throw new Error(
        "Required parameter sessionId was null or undefined when calling listAddMovie.",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        listAddMovieRequest,
        "ListAddMovieRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListDelete200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "ListDelete200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Use this method to check if an item has already been added to the list.
   * @summary Check Item Status
   * @param listId
   * @param language
   * @param movieId
   */
  public async listCheckItemStatus(
    listId: number,
    language?: string,
    movieId?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: ListCheckItemStatus200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/list/{list_id}/item_status".replace(
        "{" + "list_id" + "}",
        encodeURIComponent(String(listId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'listId' is not null or undefined
    if (listId === null || listId === undefined) {
      throw new Error(
        "Required parameter listId was null or undefined when calling listCheckItemStatus.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (movieId !== undefined) {
      localVarQueryParameters["movie_id"] = ObjectSerializer.serialize(
        movieId,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListCheckItemStatus200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "ListCheckItemStatus200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Clear all items from a list.
   * @summary Clear
   * @param listId
   * @param sessionId
   * @param confirm
   */
  public async listClear(
    listId: number,
    sessionId: string,
    confirm: boolean,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: ListDelete200Response }> {
    const localVarPath =
      this.basePath +
      "/3/list/{list_id}/clear".replace(
        "{" + "list_id" + "}",
        encodeURIComponent(String(listId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'listId' is not null or undefined
    if (listId === null || listId === undefined) {
      throw new Error(
        "Required parameter listId was null or undefined when calling listClear.",
      );
    }

    // verify required parameter 'sessionId' is not null or undefined
    if (sessionId === null || sessionId === undefined) {
      throw new Error(
        "Required parameter sessionId was null or undefined when calling listClear.",
      );
    }

    // verify required parameter 'confirm' is not null or undefined
    if (confirm === null || confirm === undefined) {
      throw new Error(
        "Required parameter confirm was null or undefined when calling listClear.",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    if (confirm !== undefined) {
      localVarQueryParameters["confirm"] = ObjectSerializer.serialize(
        confirm,
        "boolean",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListDelete200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "ListDelete200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Create
   * @param sessionId
   * @param movieAddRatingRequest
   */
  public async listCreate(
    sessionId: string,
    movieAddRatingRequest?: MovieAddRatingRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: ListCreate200Response }> {
    const localVarPath = this.basePath + "/3/list";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'sessionId' is not null or undefined
    if (sessionId === null || sessionId === undefined) {
      throw new Error(
        "Required parameter sessionId was null or undefined when calling listCreate.",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        movieAddRatingRequest,
        "MovieAddRatingRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListCreate200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "ListCreate200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Delete a list.
   * @summary Delete
   * @param listId
   * @param sessionId
   */
  public async listDelete(
    listId: number,
    sessionId: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: ListDelete200Response }> {
    const localVarPath =
      this.basePath +
      "/3/list/{list_id}".replace(
        "{" + "list_id" + "}",
        encodeURIComponent(String(listId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'listId' is not null or undefined
    if (listId === null || listId === undefined) {
      throw new Error(
        "Required parameter listId was null or undefined when calling listDelete.",
      );
    }

    // verify required parameter 'sessionId' is not null or undefined
    if (sessionId === null || sessionId === undefined) {
      throw new Error(
        "Required parameter sessionId was null or undefined when calling listDelete.",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListDelete200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "ListDelete200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Details
   * @param listId
   * @param language
   * @param page
   */
  public async listDetails(
    listId: number,
    language?: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: ListDetails200Response }> {
    const localVarPath =
      this.basePath +
      "/3/list/{list_id}".replace(
        "{" + "list_id" + "}",
        encodeURIComponent(String(listId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'listId' is not null or undefined
    if (listId === null || listId === undefined) {
      throw new Error(
        "Required parameter listId was null or undefined when calling listDetails.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListDetails200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "ListDetails200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Remove a movie from a list.
   * @summary Remove Movie
   * @param listId
   * @param sessionId
   * @param movieAddRatingRequest
   */
  public async listRemoveMovie(
    listId: number,
    sessionId: string,
    movieAddRatingRequest?: MovieAddRatingRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieDeleteRating200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/list/{list_id}/remove_item".replace(
        "{" + "list_id" + "}",
        encodeURIComponent(String(listId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'listId' is not null or undefined
    if (listId === null || listId === undefined) {
      throw new Error(
        "Required parameter listId was null or undefined when calling listRemoveMovie.",
      );
    }

    // verify required parameter 'sessionId' is not null or undefined
    if (sessionId === null || sessionId === undefined) {
      throw new Error(
        "Required parameter sessionId was null or undefined when calling listRemoveMovie.",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        movieAddRatingRequest,
        "MovieAddRatingRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieDeleteRating200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieDeleteRating200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the lists that a TV series has been added to.
   * @summary Lists
   * @param seriesId
   * @param language
   * @param page
   */
  public async listsCopy(
    seriesId: number,
    language?: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: ListsCopy200Response }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/lists".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling listsCopy.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ListsCopy200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, "ListsCopy200Response");
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the rating, watchlist and favourite status of an account.
   * @summary Account States
   * @param movieId
   * @param sessionId
   * @param guestSessionId
   */
  public async movieAccountStates(
    movieId: number,
    sessionId?: string,
    guestSessionId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieAccountStates200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/account_states".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieAccountStates.",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    if (guestSessionId !== undefined) {
      localVarQueryParameters["guest_session_id"] = ObjectSerializer.serialize(
        guestSessionId,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieAccountStates200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieAccountStates200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Rate a movie and save it to your rated list.
   * @summary Add Rating
   * @param movieId
   * @param contentType
   * @param guestSessionId
   * @param sessionId
   * @param movieAddRatingRequest
   */
  public async movieAddRating(
    movieId: number,
    contentType: string,
    guestSessionId?: string,
    sessionId?: string,
    movieAddRatingRequest?: MovieAddRatingRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieAddRating200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/rating".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieAddRating.",
      );
    }

    // verify required parameter 'contentType' is not null or undefined
    if (contentType === null || contentType === undefined) {
      throw new Error(
        "Required parameter contentType was null or undefined when calling movieAddRating.",
      );
    }

    if (guestSessionId !== undefined) {
      localVarQueryParameters["guest_session_id"] = ObjectSerializer.serialize(
        guestSessionId,
        "string",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    localVarHeaderParams["Content-Type"] = ObjectSerializer.serialize(
      contentType,
      "string",
    );
    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        movieAddRatingRequest,
        "MovieAddRatingRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieAddRating200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieAddRating200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the alternative titles for a movie.
   * @summary Alternative Titles
   * @param movieId
   * @param country specify a ISO-3166-1 value to filter the results
   */
  public async movieAlternativeTitles(
    movieId: number,
    country?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieAlternativeTitles200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/alternative_titles".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieAlternativeTitles.",
      );
    }

    if (country !== undefined) {
      localVarQueryParameters["country"] = ObjectSerializer.serialize(
        country,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieAlternativeTitles200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieAlternativeTitles200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the recent changes for a movie.
   * @summary Changes
   * @param movieId
   * @param endDate
   * @param page
   * @param startDate
   */
  public async movieChanges(
    movieId: number,
    endDate?: string,
    page?: number,
    startDate?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieChanges200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/changes".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieChanges.",
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["end_date"] = ObjectSerializer.serialize(
        endDate,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["start_date"] = ObjectSerializer.serialize(
        startDate,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieChanges200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieChanges200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Credits
   * @param movieId
   * @param language
   */
  public async movieCredits(
    movieId: number,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieCredits200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/credits".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieCredits.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieCredits200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieCredits200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Delete a user rating.
   * @summary Delete Rating
   * @param movieId
   * @param contentType
   * @param guestSessionId
   * @param sessionId
   */
  public async movieDeleteRating(
    movieId: number,
    contentType?: string,
    guestSessionId?: string,
    sessionId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieDeleteRating200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/rating".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieDeleteRating.",
      );
    }

    if (guestSessionId !== undefined) {
      localVarQueryParameters["guest_session_id"] = ObjectSerializer.serialize(
        guestSessionId,
        "string",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    localVarHeaderParams["Content-Type"] = ObjectSerializer.serialize(
      contentType,
      "string",
    );
    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieDeleteRating200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieDeleteRating200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the top level details of a movie by ID.
   * @summary Details
   * @param movieId
   * @param appendToResponse comma separated list of endpoints within this namespace, 20 items max
   * @param language
   */
  public async movieDetails(
    movieId: number,
    appendToResponse?: string,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieDetails200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieDetails.",
      );
    }

    if (appendToResponse !== undefined) {
      localVarQueryParameters["append_to_response"] =
        ObjectSerializer.serialize(appendToResponse, "string");
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieDetails200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieDetails200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary External IDs
   * @param movieId
   */
  public async movieExternalIds(
    movieId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieExternalIds200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/external_ids".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieExternalIds.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieExternalIds200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieExternalIds200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the images that belong to a movie.
   * @summary Images
   * @param movieId
   * @param includeImageLanguage specify a comma separated list of ISO-639-1 values to query, for example: &#x60;en,null&#x60;
   * @param language
   */
  public async movieImages(
    movieId: number,
    includeImageLanguage?: string,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: MovieImages200Response }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/images".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieImages.",
      );
    }

    if (includeImageLanguage !== undefined) {
      localVarQueryParameters["include_image_language"] =
        ObjectSerializer.serialize(includeImageLanguage, "string");
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieImages200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieImages200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Keywords
   * @param movieId
   */
  public async movieKeywords(
    movieId: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieKeywords200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/keywords".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieKeywords.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieKeywords200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieKeywords200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the newest movie ID.
   * @summary Latest
   */
  public async movieLatestId(
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieLatestId200Response;
  }> {
    const localVarPath = this.basePath + "/3/movie/latest";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieLatestId200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieLatestId200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the lists that a movie has been added to.
   * @summary Lists
   * @param movieId
   * @param language
   * @param page
   */
  public async movieLists(
    movieId: number,
    language?: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: MovieLists200Response }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/lists".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieLists.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieLists200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieLists200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a list of movies that are currently in theatres.
   * @summary Now Playing
   * @param language
   * @param page
   * @param region ISO-3166-1 code
   */
  public async movieNowPlayingList(
    language?: string,
    page?: number,
    region?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieNowPlayingList200Response;
  }> {
    const localVarPath = this.basePath + "/3/movie/now_playing";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (region !== undefined) {
      localVarQueryParameters["region"] = ObjectSerializer.serialize(
        region,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieNowPlayingList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieNowPlayingList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a list of movies ordered by popularity.
   * @summary Popular
   * @param language
   * @param page
   * @param region ISO-3166-1 code
   */
  public async moviePopularList(
    language?: string,
    page?: number,
    region?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MoviePopularList200Response;
  }> {
    const localVarPath = this.basePath + "/3/movie/popular";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (region !== undefined) {
      localVarQueryParameters["region"] = ObjectSerializer.serialize(
        region,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MoviePopularList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MoviePopularList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Recommendations
   * @param movieId
   * @param language
   * @param page
   */
  public async movieRecommendations(
    movieId: number,
    language?: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: object }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/recommendations".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieRecommendations.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{ response: http.IncomingMessage; body: object }>(
        (resolve, reject) => {
          localVarRequest(localVarRequestOptions, (error, response, body) => {
            if (error) {
              reject(error);
            } else {
              if (
                response.statusCode &&
                response.statusCode >= 200 &&
                response.statusCode <= 299
              ) {
                body = ObjectSerializer.deserialize(body, "object");
                resolve({ response: response, body: body });
              } else {
                reject(new HttpError(response, body, response.statusCode));
              }
            }
          });
        },
      );
    });
  }
  /**
   * Get the release dates and certifications for a movie.
   * @summary Release Dates
   * @param movieId
   */
  public async movieReleaseDates(
    movieId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieReleaseDates200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/release_dates".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieReleaseDates.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieReleaseDates200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieReleaseDates200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the user reviews for a movie.
   * @summary Reviews
   * @param movieId
   * @param language
   * @param page
   */
  public async movieReviews(
    movieId: number,
    language?: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieReviews200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/reviews".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieReviews.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieReviews200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieReviews200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the similar movies based on genres and keywords.
   * @summary Similar
   * @param movieId
   * @param language
   * @param page
   */
  public async movieSimilar(
    movieId: number,
    language?: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieSimilar200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/similar".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieSimilar.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieSimilar200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieSimilar200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a list of movies ordered by rating.
   * @summary Top Rated
   * @param language
   * @param page
   * @param region ISO-3166-1 code
   */
  public async movieTopRatedList(
    language?: string,
    page?: number,
    region?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieTopRatedList200Response;
  }> {
    const localVarPath = this.basePath + "/3/movie/top_rated";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (region !== undefined) {
      localVarQueryParameters["region"] = ObjectSerializer.serialize(
        region,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieTopRatedList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieTopRatedList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the translations for a movie.
   * @summary Translations
   * @param movieId
   */
  public async movieTranslations(
    movieId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieTranslations200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/translations".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieTranslations.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieTranslations200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieTranslations200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a list of movies that are being released soon.
   * @summary Upcoming
   * @param language
   * @param page
   * @param region ISO-3166-1 code
   */
  public async movieUpcomingList(
    language?: string,
    page?: number,
    region?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieUpcomingList200Response;
  }> {
    const localVarPath = this.basePath + "/3/movie/upcoming";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (region !== undefined) {
      localVarQueryParameters["region"] = ObjectSerializer.serialize(
        region,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieUpcomingList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieUpcomingList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Videos
   * @param movieId
   * @param language
   */
  public async movieVideos(
    movieId: number,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: MovieVideos200Response }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/videos".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieVideos.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieVideos200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieVideos200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the list of streaming providers we have for a movie.
   * @summary Watch Providers
   * @param movieId
   */
  public async movieWatchProviders(
    movieId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieWatchProviders200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/movie/{movie_id}/watch/providers".replace(
        "{" + "movie_id" + "}",
        encodeURIComponent(String(movieId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'movieId' is not null or undefined
    if (movieId === null || movieId === undefined) {
      throw new Error(
        "Required parameter movieId was null or undefined when calling movieWatchProviders.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieWatchProviders200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieWatchProviders200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Details
   * @param networkId
   */
  public async networkDetails(
    networkId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: NetworkDetails200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/network/{network_id}".replace(
        "{" + "network_id" + "}",
        encodeURIComponent(String(networkId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'networkId' is not null or undefined
    if (networkId === null || networkId === undefined) {
      throw new Error(
        "Required parameter networkId was null or undefined when calling networkDetails.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: NetworkDetails200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "NetworkDetails200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the recent changes for a person.
   * @summary Changes
   * @param personId
   * @param endDate
   * @param page
   * @param startDate
   */
  public async personChanges(
    personId: number,
    endDate?: string,
    page?: number,
    startDate?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: PersonChanges200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/person/{person_id}/changes".replace(
        "{" + "person_id" + "}",
        encodeURIComponent(String(personId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'personId' is not null or undefined
    if (personId === null || personId === undefined) {
      throw new Error(
        "Required parameter personId was null or undefined when calling personChanges.",
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["end_date"] = ObjectSerializer.serialize(
        endDate,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["start_date"] = ObjectSerializer.serialize(
        startDate,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PersonChanges200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "PersonChanges200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the combined movie and TV credits that belong to a person.
   * @summary Combined Credits
   * @param personId
   * @param language
   */
  public async personCombinedCredits(
    personId: string,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: PersonCombinedCredits200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/person/{person_id}/combined_credits".replace(
        "{" + "person_id" + "}",
        encodeURIComponent(String(personId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'personId' is not null or undefined
    if (personId === null || personId === undefined) {
      throw new Error(
        "Required parameter personId was null or undefined when calling personCombinedCredits.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PersonCombinedCredits200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "PersonCombinedCredits200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Query the top level details of a person.
   * @summary Details
   * @param personId
   * @param appendToResponse comma separated list of endpoints within this namespace, 20 items max
   * @param language
   */
  public async personDetails(
    personId: number,
    appendToResponse?: string,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: PersonDetails200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/person/{person_id}".replace(
        "{" + "person_id" + "}",
        encodeURIComponent(String(personId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'personId' is not null or undefined
    if (personId === null || personId === undefined) {
      throw new Error(
        "Required parameter personId was null or undefined when calling personDetails.",
      );
    }

    if (appendToResponse !== undefined) {
      localVarQueryParameters["append_to_response"] =
        ObjectSerializer.serialize(appendToResponse, "string");
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PersonDetails200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "PersonDetails200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the external ID\'s that belong to a person.
   * @summary External IDs
   * @param personId
   */
  public async personExternalIds(
    personId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: PersonExternalIds200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/person/{person_id}/external_ids".replace(
        "{" + "person_id" + "}",
        encodeURIComponent(String(personId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'personId' is not null or undefined
    if (personId === null || personId === undefined) {
      throw new Error(
        "Required parameter personId was null or undefined when calling personExternalIds.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PersonExternalIds200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "PersonExternalIds200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the profile images that belong to a person.
   * @summary Images
   * @param personId
   */
  public async personImages(
    personId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: PersonImages200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/person/{person_id}/images".replace(
        "{" + "person_id" + "}",
        encodeURIComponent(String(personId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'personId' is not null or undefined
    if (personId === null || personId === undefined) {
      throw new Error(
        "Required parameter personId was null or undefined when calling personImages.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PersonImages200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "PersonImages200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the newest created person. This is a live response and will continuously change.
   * @summary Latest
   */
  public async personLatestId(
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: PersonLatestId200Response;
  }> {
    const localVarPath = this.basePath + "/3/person/latest";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PersonLatestId200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "PersonLatestId200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the movie credits for a person.
   * @summary Movie Credits
   * @param personId
   * @param language
   */
  public async personMovieCredits(
    personId: number,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: PersonMovieCredits200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/person/{person_id}/movie_credits".replace(
        "{" + "person_id" + "}",
        encodeURIComponent(String(personId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'personId' is not null or undefined
    if (personId === null || personId === undefined) {
      throw new Error(
        "Required parameter personId was null or undefined when calling personMovieCredits.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PersonMovieCredits200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "PersonMovieCredits200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a list of people ordered by popularity.
   * @summary Popular
   * @param language
   * @param page
   */
  public async personPopularList(
    language?: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: PersonPopularList200Response;
  }> {
    const localVarPath = this.basePath + "/3/person/popular";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PersonPopularList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "PersonPopularList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the tagged images for a person.
   * @summary Tagged Images
   * @param personId
   * @param page
   */
  public async personTaggedImages(
    personId: number,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: PersonTaggedImages200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/person/{person_id}/tagged_images".replace(
        "{" + "person_id" + "}",
        encodeURIComponent(String(personId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'personId' is not null or undefined
    if (personId === null || personId === undefined) {
      throw new Error(
        "Required parameter personId was null or undefined when calling personTaggedImages.",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PersonTaggedImages200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "PersonTaggedImages200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the TV credits that belong to a person.
   * @summary TV Credits
   * @param personId
   * @param language
   */
  public async personTvCredits(
    personId: number,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: PersonTvCredits200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/person/{person_id}/tv_credits".replace(
        "{" + "person_id" + "}",
        encodeURIComponent(String(personId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'personId' is not null or undefined
    if (personId === null || personId === undefined) {
      throw new Error(
        "Required parameter personId was null or undefined when calling personTvCredits.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: PersonTvCredits200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "PersonTvCredits200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Retrieve the details of a movie or TV show review.
   * @summary Details
   * @param reviewId
   */
  public async reviewDetails(
    reviewId: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: ReviewDetails200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/review/{review_id}".replace(
        "{" + "review_id" + "}",
        encodeURIComponent(String(reviewId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'reviewId' is not null or undefined
    if (reviewId === null || reviewId === undefined) {
      throw new Error(
        "Required parameter reviewId was null or undefined when calling reviewDetails.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: ReviewDetails200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "ReviewDetails200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Search for collections by their original, translated and alternative names.
   * @summary Collection
   * @param query
   * @param includeAdult
   * @param language
   * @param page
   * @param region
   */
  public async searchCollection(
    query: string,
    includeAdult?: boolean,
    language?: string,
    page?: number,
    region?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: SearchCollection200Response;
  }> {
    const localVarPath = this.basePath + "/3/search/collection";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'query' is not null or undefined
    if (query === null || query === undefined) {
      throw new Error(
        "Required parameter query was null or undefined when calling searchCollection.",
      );
    }

    if (query !== undefined) {
      localVarQueryParameters["query"] = ObjectSerializer.serialize(
        query,
        "string",
      );
    }

    if (includeAdult !== undefined) {
      localVarQueryParameters["include_adult"] = ObjectSerializer.serialize(
        includeAdult,
        "boolean",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (region !== undefined) {
      localVarQueryParameters["region"] = ObjectSerializer.serialize(
        region,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: SearchCollection200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "SearchCollection200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Search for companies by their original and alternative names.
   * @summary Company
   * @param query
   * @param page
   */
  public async searchCompany(
    query: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: SearchCompany200Response;
  }> {
    const localVarPath = this.basePath + "/3/search/company";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'query' is not null or undefined
    if (query === null || query === undefined) {
      throw new Error(
        "Required parameter query was null or undefined when calling searchCompany.",
      );
    }

    if (query !== undefined) {
      localVarQueryParameters["query"] = ObjectSerializer.serialize(
        query,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: SearchCompany200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "SearchCompany200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Search for keywords by their name.
   * @summary Keyword
   * @param query
   * @param page
   */
  public async searchKeyword(
    query: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: SearchKeyword200Response;
  }> {
    const localVarPath = this.basePath + "/3/search/keyword";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'query' is not null or undefined
    if (query === null || query === undefined) {
      throw new Error(
        "Required parameter query was null or undefined when calling searchKeyword.",
      );
    }

    if (query !== undefined) {
      localVarQueryParameters["query"] = ObjectSerializer.serialize(
        query,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: SearchKeyword200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "SearchKeyword200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Search for movies by their original, translated and alternative titles.
   * @summary Movie
   * @param query
   * @param includeAdult
   * @param language
   * @param primaryReleaseYear
   * @param page
   * @param region
   * @param year
   */
  public async searchMovie(
    query: string,
    includeAdult?: boolean,
    language?: string,
    primaryReleaseYear?: string,
    page?: number,
    region?: string,
    year?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: SearchMovie200Response }> {
    const localVarPath = this.basePath + "/3/search/movie";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'query' is not null or undefined
    if (query === null || query === undefined) {
      throw new Error(
        "Required parameter query was null or undefined when calling searchMovie.",
      );
    }

    if (query !== undefined) {
      localVarQueryParameters["query"] = ObjectSerializer.serialize(
        query,
        "string",
      );
    }

    if (includeAdult !== undefined) {
      localVarQueryParameters["include_adult"] = ObjectSerializer.serialize(
        includeAdult,
        "boolean",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (primaryReleaseYear !== undefined) {
      localVarQueryParameters["primary_release_year"] =
        ObjectSerializer.serialize(primaryReleaseYear, "string");
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (region !== undefined) {
      localVarQueryParameters["region"] = ObjectSerializer.serialize(
        region,
        "string",
      );
    }

    if (year !== undefined) {
      localVarQueryParameters["year"] = ObjectSerializer.serialize(
        year,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: SearchMovie200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "SearchMovie200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Use multi search when you want to search for movies, TV shows and people in a single request.
   * @summary Multi
   * @param query
   * @param includeAdult
   * @param language
   * @param page
   */
  public async searchMulti(
    query: string,
    includeAdult?: boolean,
    language?: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: SearchMulti200Response }> {
    const localVarPath = this.basePath + "/3/search/multi";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'query' is not null or undefined
    if (query === null || query === undefined) {
      throw new Error(
        "Required parameter query was null or undefined when calling searchMulti.",
      );
    }

    if (query !== undefined) {
      localVarQueryParameters["query"] = ObjectSerializer.serialize(
        query,
        "string",
      );
    }

    if (includeAdult !== undefined) {
      localVarQueryParameters["include_adult"] = ObjectSerializer.serialize(
        includeAdult,
        "boolean",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: SearchMulti200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "SearchMulti200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Search for people by their name and also known as names.
   * @summary Person
   * @param query
   * @param includeAdult
   * @param language
   * @param page
   */
  public async searchPerson(
    query: string,
    includeAdult?: boolean,
    language?: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: SearchPerson200Response;
  }> {
    const localVarPath = this.basePath + "/3/search/person";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'query' is not null or undefined
    if (query === null || query === undefined) {
      throw new Error(
        "Required parameter query was null or undefined when calling searchPerson.",
      );
    }

    if (query !== undefined) {
      localVarQueryParameters["query"] = ObjectSerializer.serialize(
        query,
        "string",
      );
    }

    if (includeAdult !== undefined) {
      localVarQueryParameters["include_adult"] = ObjectSerializer.serialize(
        includeAdult,
        "boolean",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: SearchPerson200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "SearchPerson200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Search for TV shows by their original, translated and also known as names.
   * @summary TV
   * @param query
   * @param firstAirDateYear Search only the first air date. Valid values are: 1000..9999
   * @param includeAdult
   * @param language
   * @param page
   * @param year Search the first air date and all episode air dates. Valid values are: 1000..9999
   */
  public async searchTv(
    query: string,
    firstAirDateYear?: number,
    includeAdult?: boolean,
    language?: string,
    page?: number,
    year?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: SearchTv200Response }> {
    const localVarPath = this.basePath + "/3/search/tv";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'query' is not null or undefined
    if (query === null || query === undefined) {
      throw new Error(
        "Required parameter query was null or undefined when calling searchTv.",
      );
    }

    if (query !== undefined) {
      localVarQueryParameters["query"] = ObjectSerializer.serialize(
        query,
        "string",
      );
    }

    if (firstAirDateYear !== undefined) {
      localVarQueryParameters["first_air_date_year"] =
        ObjectSerializer.serialize(firstAirDateYear, "number");
    }

    if (includeAdult !== undefined) {
      localVarQueryParameters["include_adult"] = ObjectSerializer.serialize(
        includeAdult,
        "boolean",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (year !== undefined) {
      localVarQueryParameters["year"] = ObjectSerializer.serialize(
        year,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: SearchTv200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, "SearchTv200Response");
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the translations that belong to a person.
   * @summary Translations
   * @param personId
   */
  public async translations(
    personId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: Translations200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/person/{person_id}/translations".replace(
        "{" + "person_id" + "}",
        encodeURIComponent(String(personId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'personId' is not null or undefined
    if (personId === null || personId === undefined) {
      throw new Error(
        "Required parameter personId was null or undefined when calling translations.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: Translations200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "Translations200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the trending movies, TV shows and people.
   * @summary All
   * @param timeWindow
   * @param language &#x60;ISO-639-1&#x60;-&#x60;ISO-3166-1&#x60; code
   */
  public async trendingAll(
    timeWindow: "day" | "week",
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: TrendingAll200Response }> {
    const localVarPath =
      this.basePath +
      "/3/trending/all/{time_window}".replace(
        "{" + "time_window" + "}",
        encodeURIComponent(String(timeWindow)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'timeWindow' is not null or undefined
    if (timeWindow === null || timeWindow === undefined) {
      throw new Error(
        "Required parameter timeWindow was null or undefined when calling trendingAll.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TrendingAll200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TrendingAll200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the trending movies on TMDB.
   * @summary Movies
   * @param timeWindow
   * @param language &#x60;ISO-639-1&#x60;-&#x60;ISO-3166-1&#x60; code
   */
  public async trendingMovies(
    timeWindow: "day" | "week",
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: TrendingAll200Response }> {
    const localVarPath =
      this.basePath +
      "/3/trending/movie/{time_window}".replace(
        "{" + "time_window" + "}",
        encodeURIComponent(String(timeWindow)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'timeWindow' is not null or undefined
    if (timeWindow === null || timeWindow === undefined) {
      throw new Error(
        "Required parameter timeWindow was null or undefined when calling trendingMovies.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TrendingAll200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TrendingAll200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the trending people on TMDB.
   * @summary People
   * @param timeWindow
   * @param language &#x60;ISO-639-1&#x60;-&#x60;ISO-3166-1&#x60; code
   */
  public async trendingPeople(
    timeWindow: "day" | "week",
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TrendingPeople200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/trending/person/{time_window}".replace(
        "{" + "time_window" + "}",
        encodeURIComponent(String(timeWindow)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'timeWindow' is not null or undefined
    if (timeWindow === null || timeWindow === undefined) {
      throw new Error(
        "Required parameter timeWindow was null or undefined when calling trendingPeople.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TrendingPeople200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TrendingPeople200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the trending TV shows on TMDB.
   * @summary TV
   * @param timeWindow
   * @param language &#x60;ISO-639-1&#x60;-&#x60;ISO-3166-1&#x60; code
   */
  public async trendingTv(
    timeWindow: "day" | "week",
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: TrendingTv200Response }> {
    const localVarPath =
      this.basePath +
      "/3/trending/tv/{time_window}".replace(
        "{" + "time_window" + "}",
        encodeURIComponent(String(timeWindow)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'timeWindow' is not null or undefined
    if (timeWindow === null || timeWindow === undefined) {
      throw new Error(
        "Required parameter timeWindow was null or undefined when calling trendingTv.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TrendingTv200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TrendingTv200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the rating, watchlist and favourite status.
   * @summary Account States
   * @param seriesId
   * @param seasonNumber
   * @param episodeNumber
   * @param sessionId
   * @param guestSessionId
   */
  public async tvEpisodeAccountStates(
    seriesId: number,
    seasonNumber: number,
    episodeNumber: number,
    sessionId?: string,
    guestSessionId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieAccountStates200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/account_states"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        )
        .replace(
          "{" + "episode_number" + "}",
          encodeURIComponent(String(episodeNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvEpisodeAccountStates.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvEpisodeAccountStates.",
      );
    }

    // verify required parameter 'episodeNumber' is not null or undefined
    if (episodeNumber === null || episodeNumber === undefined) {
      throw new Error(
        "Required parameter episodeNumber was null or undefined when calling tvEpisodeAccountStates.",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    if (guestSessionId !== undefined) {
      localVarQueryParameters["guest_session_id"] = ObjectSerializer.serialize(
        guestSessionId,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieAccountStates200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieAccountStates200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Rate a TV episode and save it to your rated list.
   * @summary Add Rating
   * @param seriesId
   * @param contentType
   * @param seasonNumber
   * @param episodeNumber
   * @param guestSessionId
   * @param sessionId
   * @param movieAddRatingRequest
   */
  public async tvEpisodeAddRating(
    seriesId: number,
    contentType: string,
    seasonNumber: number,
    episodeNumber: number,
    guestSessionId?: string,
    sessionId?: string,
    movieAddRatingRequest?: MovieAddRatingRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieAddRating200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/rating"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        )
        .replace(
          "{" + "episode_number" + "}",
          encodeURIComponent(String(episodeNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvEpisodeAddRating.",
      );
    }

    // verify required parameter 'contentType' is not null or undefined
    if (contentType === null || contentType === undefined) {
      throw new Error(
        "Required parameter contentType was null or undefined when calling tvEpisodeAddRating.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvEpisodeAddRating.",
      );
    }

    // verify required parameter 'episodeNumber' is not null or undefined
    if (episodeNumber === null || episodeNumber === undefined) {
      throw new Error(
        "Required parameter episodeNumber was null or undefined when calling tvEpisodeAddRating.",
      );
    }

    if (guestSessionId !== undefined) {
      localVarQueryParameters["guest_session_id"] = ObjectSerializer.serialize(
        guestSessionId,
        "string",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    localVarHeaderParams["Content-Type"] = ObjectSerializer.serialize(
      contentType,
      "string",
    );
    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        movieAddRatingRequest,
        "MovieAddRatingRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieAddRating200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieAddRating200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the recent changes for a TV episode.
   * @summary Changes
   * @param episodeId
   */
  public async tvEpisodeChangesById(
    episodeId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvEpisodeChangesById200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/episode/{episode_id}/changes".replace(
        "{" + "episode_id" + "}",
        encodeURIComponent(String(episodeId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'episodeId' is not null or undefined
    if (episodeId === null || episodeId === undefined) {
      throw new Error(
        "Required parameter episodeId was null or undefined when calling tvEpisodeChangesById.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvEpisodeChangesById200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvEpisodeChangesById200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Credits
   * @param seriesId
   * @param seasonNumber
   * @param episodeNumber
   * @param language
   */
  public async tvEpisodeCredits(
    seriesId: number,
    seasonNumber: number,
    episodeNumber: number,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvEpisodeCredits200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/credits"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        )
        .replace(
          "{" + "episode_number" + "}",
          encodeURIComponent(String(episodeNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvEpisodeCredits.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvEpisodeCredits.",
      );
    }

    // verify required parameter 'episodeNumber' is not null or undefined
    if (episodeNumber === null || episodeNumber === undefined) {
      throw new Error(
        "Required parameter episodeNumber was null or undefined when calling tvEpisodeCredits.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvEpisodeCredits200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvEpisodeCredits200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Delete your rating on a TV episode.
   * @summary Delete Rating
   * @param seriesId
   * @param seasonNumber
   * @param episodeNumber
   * @param contentType
   * @param guestSessionId
   * @param sessionId
   */
  public async tvEpisodeDeleteRating(
    seriesId: number,
    seasonNumber: number,
    episodeNumber: number,
    contentType?: string,
    guestSessionId?: string,
    sessionId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieDeleteRating200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/rating"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        )
        .replace(
          "{" + "episode_number" + "}",
          encodeURIComponent(String(episodeNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvEpisodeDeleteRating.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvEpisodeDeleteRating.",
      );
    }

    // verify required parameter 'episodeNumber' is not null or undefined
    if (episodeNumber === null || episodeNumber === undefined) {
      throw new Error(
        "Required parameter episodeNumber was null or undefined when calling tvEpisodeDeleteRating.",
      );
    }

    if (guestSessionId !== undefined) {
      localVarQueryParameters["guest_session_id"] = ObjectSerializer.serialize(
        guestSessionId,
        "string",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    localVarHeaderParams["Content-Type"] = ObjectSerializer.serialize(
      contentType,
      "string",
    );
    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieDeleteRating200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieDeleteRating200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Query the details of a TV episode.
   * @summary Details
   * @param seriesId
   * @param seasonNumber
   * @param episodeNumber
   * @param appendToResponse comma separated list of endpoints within this namespace, 20 items max
   * @param language
   */
  public async tvEpisodeDetails(
    seriesId: number,
    seasonNumber: number,
    episodeNumber: number,
    appendToResponse?: string,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvEpisodeDetails200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/episode/{episode_number}"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        )
        .replace(
          "{" + "episode_number" + "}",
          encodeURIComponent(String(episodeNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvEpisodeDetails.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvEpisodeDetails.",
      );
    }

    // verify required parameter 'episodeNumber' is not null or undefined
    if (episodeNumber === null || episodeNumber === undefined) {
      throw new Error(
        "Required parameter episodeNumber was null or undefined when calling tvEpisodeDetails.",
      );
    }

    if (appendToResponse !== undefined) {
      localVarQueryParameters["append_to_response"] =
        ObjectSerializer.serialize(appendToResponse, "string");
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvEpisodeDetails200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvEpisodeDetails200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a list of external IDs that have been added to a TV episode.
   * @summary External IDs
   * @param seriesId
   * @param seasonNumber
   * @param episodeNumber
   */
  public async tvEpisodeExternalIds(
    seriesId: number,
    seasonNumber: number,
    episodeNumber: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvEpisodeExternalIds200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/external_ids"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        )
        .replace(
          "{" + "episode_number" + "}",
          encodeURIComponent(String(episodeNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvEpisodeExternalIds.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvEpisodeExternalIds.",
      );
    }

    // verify required parameter 'episodeNumber' is not null or undefined
    if (episodeNumber === null || episodeNumber === undefined) {
      throw new Error(
        "Required parameter episodeNumber was null or undefined when calling tvEpisodeExternalIds.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvEpisodeExternalIds200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvEpisodeExternalIds200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the details of a TV episode group.
   * @summary Details
   * @param tvEpisodeGroupId
   */
  public async tvEpisodeGroupDetails(
    tvEpisodeGroupId: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvEpisodeGroupDetails200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/episode_group/{tv_episode_group_id}".replace(
        "{" + "tv_episode_group_id" + "}",
        encodeURIComponent(String(tvEpisodeGroupId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'tvEpisodeGroupId' is not null or undefined
    if (tvEpisodeGroupId === null || tvEpisodeGroupId === undefined) {
      throw new Error(
        "Required parameter tvEpisodeGroupId was null or undefined when calling tvEpisodeGroupDetails.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvEpisodeGroupDetails200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvEpisodeGroupDetails200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the images that belong to a TV episode.
   * @summary Images
   * @param seriesId
   * @param seasonNumber
   * @param episodeNumber
   * @param includeImageLanguage specify a comma separated list of ISO-639-1 values to query, for example: &#x60;en,null&#x60;
   * @param language
   */
  public async tvEpisodeImages(
    seriesId: number,
    seasonNumber: number,
    episodeNumber: number,
    includeImageLanguage?: string,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvEpisodeImages200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/images"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        )
        .replace(
          "{" + "episode_number" + "}",
          encodeURIComponent(String(episodeNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvEpisodeImages.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvEpisodeImages.",
      );
    }

    // verify required parameter 'episodeNumber' is not null or undefined
    if (episodeNumber === null || episodeNumber === undefined) {
      throw new Error(
        "Required parameter episodeNumber was null or undefined when calling tvEpisodeImages.",
      );
    }

    if (includeImageLanguage !== undefined) {
      localVarQueryParameters["include_image_language"] =
        ObjectSerializer.serialize(includeImageLanguage, "string");
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvEpisodeImages200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvEpisodeImages200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the translations that have been added to a TV episode.
   * @summary Translations
   * @param seriesId
   * @param seasonNumber
   * @param episodeNumber
   */
  public async tvEpisodeTranslations(
    seriesId: number,
    seasonNumber: number,
    episodeNumber: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvEpisodeTranslations200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/translations"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        )
        .replace(
          "{" + "episode_number" + "}",
          encodeURIComponent(String(episodeNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvEpisodeTranslations.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvEpisodeTranslations.",
      );
    }

    // verify required parameter 'episodeNumber' is not null or undefined
    if (episodeNumber === null || episodeNumber === undefined) {
      throw new Error(
        "Required parameter episodeNumber was null or undefined when calling tvEpisodeTranslations.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvEpisodeTranslations200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvEpisodeTranslations200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the videos that belong to a TV episode.
   * @summary Videos
   * @param seriesId
   * @param seasonNumber
   * @param episodeNumber
   * @param includeVideoLanguage filter the list results by language, supports more than one value by using a comma
   * @param language
   */
  public async tvEpisodeVideos(
    seriesId: number,
    seasonNumber: number,
    episodeNumber: number,
    includeVideoLanguage?: string,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeasonVideos200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/episode/{episode_number}/videos"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        )
        .replace(
          "{" + "episode_number" + "}",
          encodeURIComponent(String(episodeNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvEpisodeVideos.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvEpisodeVideos.",
      );
    }

    // verify required parameter 'episodeNumber' is not null or undefined
    if (episodeNumber === null || episodeNumber === undefined) {
      throw new Error(
        "Required parameter episodeNumber was null or undefined when calling tvEpisodeVideos.",
      );
    }

    if (includeVideoLanguage !== undefined) {
      localVarQueryParameters["include_video_language"] =
        ObjectSerializer.serialize(includeVideoLanguage, "string");
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeasonVideos200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeasonVideos200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the rating, watchlist and favourite status.
   * @summary Account States
   * @param seriesId
   * @param seasonNumber
   * @param sessionId
   * @param guestSessionId
   */
  public async tvSeasonAccountStates(
    seriesId: number,
    seasonNumber: number,
    sessionId?: string,
    guestSessionId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeasonAccountStates200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/account_states"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeasonAccountStates.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvSeasonAccountStates.",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    if (guestSessionId !== undefined) {
      localVarQueryParameters["guest_session_id"] = ObjectSerializer.serialize(
        guestSessionId,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeasonAccountStates200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeasonAccountStates200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the aggregate credits (cast and crew) that have been added to a TV season.
   * @summary Aggregate Credits
   * @param seriesId
   * @param seasonNumber
   * @param language
   */
  public async tvSeasonAggregateCredits(
    seriesId: number,
    seasonNumber: number,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeasonAggregateCredits200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/aggregate_credits"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeasonAggregateCredits.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvSeasonAggregateCredits.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeasonAggregateCredits200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeasonAggregateCredits200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the recent changes for a TV season.
   * @summary Changes
   * @param seasonId
   * @param endDate
   * @param page
   * @param startDate
   */
  public async tvSeasonChangesById(
    seasonId: number,
    endDate?: string,
    page?: number,
    startDate?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeasonChangesById200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/season/{season_id}/changes".replace(
        "{" + "season_id" + "}",
        encodeURIComponent(String(seasonId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seasonId' is not null or undefined
    if (seasonId === null || seasonId === undefined) {
      throw new Error(
        "Required parameter seasonId was null or undefined when calling tvSeasonChangesById.",
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["end_date"] = ObjectSerializer.serialize(
        endDate,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["start_date"] = ObjectSerializer.serialize(
        startDate,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeasonChangesById200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeasonChangesById200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Credits
   * @param seriesId
   * @param seasonNumber
   * @param language
   */
  public async tvSeasonCredits(
    seriesId: number,
    seasonNumber: number,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeasonCredits200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/credits"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeasonCredits.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvSeasonCredits.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeasonCredits200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeasonCredits200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Query the details of a TV season.
   * @summary Details
   * @param seriesId
   * @param seasonNumber
   * @param appendToResponse comma separated list of endpoints within this namespace, 20 items max
   * @param language
   */
  public async tvSeasonDetails(
    seriesId: number,
    seasonNumber: number,
    appendToResponse?: string,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeasonDetails200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeasonDetails.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvSeasonDetails.",
      );
    }

    if (appendToResponse !== undefined) {
      localVarQueryParameters["append_to_response"] =
        ObjectSerializer.serialize(appendToResponse, "string");
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeasonDetails200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeasonDetails200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a list of external IDs that have been added to a TV season.
   * @summary External IDs
   * @param seriesId
   * @param seasonNumber
   */
  public async tvSeasonExternalIds(
    seriesId: number,
    seasonNumber: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeasonExternalIds200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/external_ids"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeasonExternalIds.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvSeasonExternalIds.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeasonExternalIds200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeasonExternalIds200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the images that belong to a TV season.
   * @summary Images
   * @param seriesId
   * @param seasonNumber
   * @param includeImageLanguage specify a comma separated list of ISO-639-1 values to query, for example: &#x60;en,null&#x60;
   * @param language
   */
  public async tvSeasonImages(
    seriesId: number,
    seasonNumber: number,
    includeImageLanguage?: string,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeasonImages200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/images"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeasonImages.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvSeasonImages.",
      );
    }

    if (includeImageLanguage !== undefined) {
      localVarQueryParameters["include_image_language"] =
        ObjectSerializer.serialize(includeImageLanguage, "string");
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeasonImages200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeasonImages200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the translations for a TV season.
   * @summary Translations
   * @param seriesId
   * @param seasonNumber
   */
  public async tvSeasonTranslations(
    seriesId: number,
    seasonNumber: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeasonTranslations200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/translations"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeasonTranslations.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvSeasonTranslations.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeasonTranslations200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeasonTranslations200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the videos that belong to a TV season.
   * @summary Videos
   * @param seriesId
   * @param seasonNumber
   * @param includeVideoLanguage filter the list results by language, supports more than one value by using a comma
   * @param language
   */
  public async tvSeasonVideos(
    seriesId: number,
    seasonNumber: number,
    includeVideoLanguage?: string,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeasonVideos200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/videos"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeasonVideos.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvSeasonVideos.",
      );
    }

    if (includeVideoLanguage !== undefined) {
      localVarQueryParameters["include_video_language"] =
        ObjectSerializer.serialize(includeVideoLanguage, "string");
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeasonVideos200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeasonVideos200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the list of streaming providers we have for a TV season.
   * @summary Watch Providers
   * @param seriesId
   * @param seasonNumber
   * @param language
   */
  public async tvSeasonWatchProviders(
    seriesId: number,
    seasonNumber: number,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeasonWatchProviders200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/season/{season_number}/watch/providers"
        .replace("{" + "series_id" + "}", encodeURIComponent(String(seriesId)))
        .replace(
          "{" + "season_number" + "}",
          encodeURIComponent(String(seasonNumber)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeasonWatchProviders.",
      );
    }

    // verify required parameter 'seasonNumber' is not null or undefined
    if (seasonNumber === null || seasonNumber === undefined) {
      throw new Error(
        "Required parameter seasonNumber was null or undefined when calling tvSeasonWatchProviders.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeasonWatchProviders200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeasonWatchProviders200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the rating, watchlist and favourite status.
   * @summary Account States
   * @param seriesId
   * @param sessionId
   * @param guestSessionId
   */
  public async tvSeriesAccountStates(
    seriesId: number,
    sessionId?: string,
    guestSessionId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieAccountStates200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/account_states".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesAccountStates.",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    if (guestSessionId !== undefined) {
      localVarQueryParameters["guest_session_id"] = ObjectSerializer.serialize(
        guestSessionId,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieAccountStates200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieAccountStates200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Rate a TV show and save it to your rated list.
   * @summary Add Rating
   * @param seriesId
   * @param contentType
   * @param guestSessionId
   * @param sessionId
   * @param movieAddRatingRequest
   */
  public async tvSeriesAddRating(
    seriesId: number,
    contentType: string,
    guestSessionId?: string,
    sessionId?: string,
    movieAddRatingRequest?: MovieAddRatingRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieAddRating200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/rating".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesAddRating.",
      );
    }

    // verify required parameter 'contentType' is not null or undefined
    if (contentType === null || contentType === undefined) {
      throw new Error(
        "Required parameter contentType was null or undefined when calling tvSeriesAddRating.",
      );
    }

    if (guestSessionId !== undefined) {
      localVarQueryParameters["guest_session_id"] = ObjectSerializer.serialize(
        guestSessionId,
        "string",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    localVarHeaderParams["Content-Type"] = ObjectSerializer.serialize(
      contentType,
      "string",
    );
    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        movieAddRatingRequest,
        "MovieAddRatingRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieAddRating200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieAddRating200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the aggregate credits (cast and crew) that have been added to a TV show.
   * @summary Aggregate Credits
   * @param seriesId
   * @param language
   */
  public async tvSeriesAggregateCredits(
    seriesId: number,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesAggregateCredits200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/aggregate_credits".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesAggregateCredits.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesAggregateCredits200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesAggregateCredits200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a list of TV shows airing today.
   * @summary Airing Today
   * @param language
   * @param page
   * @param timezone
   */
  public async tvSeriesAiringTodayList(
    language?: string,
    page?: number,
    timezone?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesAiringTodayList200Response;
  }> {
    const localVarPath = this.basePath + "/3/tv/airing_today";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (timezone !== undefined) {
      localVarQueryParameters["timezone"] = ObjectSerializer.serialize(
        timezone,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesAiringTodayList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesAiringTodayList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the alternative titles that have been added to a TV show.
   * @summary Alternative Titles
   * @param seriesId
   */
  public async tvSeriesAlternativeTitles(
    seriesId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesAlternativeTitles200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/alternative_titles".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesAlternativeTitles.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesAlternativeTitles200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesAlternativeTitles200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the recent changes for a TV show.
   * @summary Changes
   * @param seriesId
   * @param endDate
   * @param page
   * @param startDate
   */
  public async tvSeriesChanges(
    seriesId: number,
    endDate?: string,
    page?: number,
    startDate?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesChanges200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/changes".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesChanges.",
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["end_date"] = ObjectSerializer.serialize(
        endDate,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["start_date"] = ObjectSerializer.serialize(
        startDate,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesChanges200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesChanges200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the content ratings that have been added to a TV show.
   * @summary Content Ratings
   * @param seriesId
   */
  public async tvSeriesContentRatings(
    seriesId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesContentRatings200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/content_ratings".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesContentRatings.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesContentRatings200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesContentRatings200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the latest season credits of a TV show.
   * @summary Credits
   * @param seriesId
   * @param language
   */
  public async tvSeriesCredits(
    seriesId: number,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesCredits200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/credits".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesCredits.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesCredits200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesCredits200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Delete Rating
   * @param seriesId
   * @param contentType
   * @param guestSessionId
   * @param sessionId
   */
  public async tvSeriesDeleteRating(
    seriesId: number,
    contentType?: string,
    guestSessionId?: string,
    sessionId?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: MovieDeleteRating200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/rating".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesDeleteRating.",
      );
    }

    if (guestSessionId !== undefined) {
      localVarQueryParameters["guest_session_id"] = ObjectSerializer.serialize(
        guestSessionId,
        "string",
      );
    }

    if (sessionId !== undefined) {
      localVarQueryParameters["session_id"] = ObjectSerializer.serialize(
        sessionId,
        "string",
      );
    }

    localVarHeaderParams["Content-Type"] = ObjectSerializer.serialize(
      contentType,
      "string",
    );
    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieDeleteRating200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieDeleteRating200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the details of a TV show.
   * @summary Details
   * @param seriesId
   * @param appendToResponse comma separated list of endpoints within this namespace, 20 items max
   * @param language
   */
  public async tvSeriesDetails(
    seriesId: number,
    appendToResponse?: string,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesDetails200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesDetails.",
      );
    }

    if (appendToResponse !== undefined) {
      localVarQueryParameters["append_to_response"] =
        ObjectSerializer.serialize(appendToResponse, "string");
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesDetails200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesDetails200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the episode groups that have been added to a TV show.
   * @summary Episode Groups
   * @param seriesId
   */
  public async tvSeriesEpisodeGroups(
    seriesId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesEpisodeGroups200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/episode_groups".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesEpisodeGroups.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesEpisodeGroups200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesEpisodeGroups200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a list of external IDs that have been added to a TV show.
   * @summary External IDs
   * @param seriesId
   */
  public async tvSeriesExternalIds(
    seriesId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesExternalIds200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/external_ids".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesExternalIds.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesExternalIds200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesExternalIds200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the images that belong to a TV series.
   * @summary Images
   * @param seriesId
   * @param includeImageLanguage specify a comma separated list of ISO-639-1 values to query, for example: &#x60;en,null&#x60;
   * @param language
   */
  public async tvSeriesImages(
    seriesId: number,
    includeImageLanguage?: string,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: MovieImages200Response }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/images".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesImages.",
      );
    }

    if (includeImageLanguage !== undefined) {
      localVarQueryParameters["include_image_language"] =
        ObjectSerializer.serialize(includeImageLanguage, "string");
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: MovieImages200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "MovieImages200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a list of keywords that have been added to a TV show.
   * @summary Keywords
   * @param seriesId
   */
  public async tvSeriesKeywords(
    seriesId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesKeywords200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/keywords".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesKeywords.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesKeywords200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesKeywords200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the newest TV show ID.
   * @summary Latest
   */
  public async tvSeriesLatestId(
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesLatestId200Response;
  }> {
    const localVarPath = this.basePath + "/3/tv/latest";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesLatestId200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesLatestId200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a list of TV shows that air in the next 7 days.
   * @summary On The Air
   * @param language
   * @param page
   * @param timezone
   */
  public async tvSeriesOnTheAirList(
    language?: string,
    page?: number,
    timezone?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesOnTheAirList200Response;
  }> {
    const localVarPath = this.basePath + "/3/tv/on_the_air";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    if (timezone !== undefined) {
      localVarQueryParameters["timezone"] = ObjectSerializer.serialize(
        timezone,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesOnTheAirList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesOnTheAirList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a list of TV shows ordered by popularity.
   * @summary Popular
   * @param language
   * @param page
   */
  public async tvSeriesPopularList(
    language?: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesPopularList200Response;
  }> {
    const localVarPath = this.basePath + "/3/tv/popular";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesPopularList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesPopularList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Recommendations
   * @param seriesId
   * @param language
   * @param page
   */
  public async tvSeriesRecommendations(
    seriesId: number,
    language?: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesRecommendations200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/recommendations".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesRecommendations.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesRecommendations200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesRecommendations200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the reviews that have been added to a TV show.
   * @summary Reviews
   * @param seriesId
   * @param language
   * @param page
   */
  public async tvSeriesReviews(
    seriesId: number,
    language?: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesReviews200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/reviews".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesReviews.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesReviews200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesReviews200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the seasons and episodes that have screened theatrically.
   * @summary Screened Theatrically
   * @param seriesId
   */
  public async tvSeriesScreenedTheatrically(
    seriesId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesScreenedTheatrically200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/screened_theatrically".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesScreenedTheatrically.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesScreenedTheatrically200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesScreenedTheatrically200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the similar TV shows.
   * @summary Similar
   * @param seriesId
   * @param language
   * @param page
   */
  public async tvSeriesSimilar(
    seriesId: string,
    language?: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesSimilar200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/similar".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesSimilar.",
      );
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesSimilar200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesSimilar200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get a list of TV shows ordered by rating.
   * @summary Top Rated
   * @param language
   * @param page
   */
  public async tvSeriesTopRatedList(
    language?: string,
    page?: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesTopRatedList200Response;
  }> {
    const localVarPath = this.basePath + "/3/tv/top_rated";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesTopRatedList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesTopRatedList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the translations that have been added to a TV show.
   * @summary Translations
   * @param seriesId
   */
  public async tvSeriesTranslations(
    seriesId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesTranslations200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/translations".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesTranslations.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesTranslations200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesTranslations200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the videos that belong to a TV show.
   * @summary Videos
   * @param seriesId
   * @param includeVideoLanguage filter the list results by language, supports more than one value by using a comma
   * @param language
   */
  public async tvSeriesVideos(
    seriesId: number,
    includeVideoLanguage?: string,
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesVideos200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/videos".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesVideos.",
      );
    }

    if (includeVideoLanguage !== undefined) {
      localVarQueryParameters["include_video_language"] =
        ObjectSerializer.serialize(includeVideoLanguage, "string");
    }

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesVideos200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesVideos200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the list of streaming providers we have for a TV show.
   * @summary Watch Providers
   * @param seriesId
   */
  public async tvSeriesWatchProviders(
    seriesId: number,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: TvSeriesWatchProviders200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/3/tv/{series_id}/watch/providers".replace(
        "{" + "series_id" + "}",
        encodeURIComponent(String(seriesId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'seriesId' is not null or undefined
    if (seriesId === null || seriesId === undefined) {
      throw new Error(
        "Required parameter seriesId was null or undefined when calling tvSeriesWatchProviders.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: TvSeriesWatchProviders200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "TvSeriesWatchProviders200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the list of streaming providers we have for TV shows.
   * @summary TV Providers
   * @param language
   * @param watchRegion
   */
  public async watchProviderTvList(
    language?: string,
    watchRegion?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: WatchProvidersMovieList200Response;
  }> {
    const localVarPath = this.basePath + "/3/watch/providers/tv";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (watchRegion !== undefined) {
      localVarQueryParameters["watch_region"] = ObjectSerializer.serialize(
        watchRegion,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: WatchProvidersMovieList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "WatchProvidersMovieList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the list of the countries we have watch provider (OTT/streaming) data for.
   * @summary Available Regions
   * @param language
   */
  public async watchProvidersAvailableRegions(
    language?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: WatchProvidersAvailableRegions200Response;
  }> {
    const localVarPath = this.basePath + "/3/watch/providers/regions";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: WatchProvidersAvailableRegions200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "WatchProvidersAvailableRegions200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   * Get the list of streaming providers we have for movies.
   * @summary Movie Providers
   * @param language
   * @param watchRegion
   */
  public async watchProvidersMovieList(
    language?: string,
    watchRegion?: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: WatchProvidersMovieList200Response;
  }> {
    const localVarPath = this.basePath + "/3/watch/providers/movie";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    if (language !== undefined) {
      localVarQueryParameters["language"] = ObjectSerializer.serialize(
        language,
        "string",
      );
    }

    if (watchRegion !== undefined) {
      localVarQueryParameters["watch_region"] = ObjectSerializer.serialize(
        watchRegion,
        "string",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    if (this.authentications.sec0.apiKey) {
      authenticationPromise = authenticationPromise.then(() =>
        this.authentications.sec0.applyToRequest(localVarRequestOptions),
      );
    }
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: WatchProvidersMovieList200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "WatchProvidersMovieList200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
}
